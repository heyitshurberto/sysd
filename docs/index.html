<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5, user-scalable=yes">
<style>

/* Just make tables horizontally scrollable */
.table-container {
    overflow-x: auto;
    border: 1px solid #ccc;
    margin: 10px 0;
}

table {
    min-width: 800px; /* Force scroll on mobile */
    width: 100%;
}

/* Slightly smaller text on mobile */
@media (max-width: 200px) {
    body { font-size: 13px; }
    table { font-size: 12px; }
}
</style>
<div style="position: absolute; top: 7px; left: 4.5px;">
  <a href="#" onclick="customConfirm('Visit @eugene0112358 on X?', 'https://x.com/eugene0112358'); return false;" style="text-decoration: none; color: inherit; font-family: monospace; font-size: 11px; max-width: 100px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: inline-block; padding: 2px 4px; border-radius: 3px; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor=document.body.classList.contains('dark-mode')?'rgba(120,120,120,0.25)':'rgba(0,0,0,0.1)'" onmouseout="this.style.backgroundColor='transparent'">@eugene0112358</a></div>
<style>
    @media (max-width: 768px) {
        div[style*="position: absolute; top: 7px; left: 7px;"] {
            position: static !important;
            margin-bottom: 8px !important;
            margin-top: 4px !important;
            padding-left: 4px !important;
        }
        div[style*="position: absolute; top: 7px; left: 7px;"] a {
            font-size: 5px !important;
            max-width: 70px !important;
        }
    }
</style>
    <title style="font-family: 'Monaco', monospace;">Eugene's Non-Profit</title>
    <!-- PWA meta tags and manifest -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Eugene's Non-Profit">
    <meta name="theme-color" content="#1a1a1a">
    <!-- Favicon for all devices and browsers -->
    <link rel="icon" type="image/jpeg" href="logo.jpeg" sizes="any">
    <link rel="icon" type="image/jpeg" href="logo.jpeg">
    <link rel="shortcut icon" type="image/jpeg" href="logo.jpeg">
    <!-- Apple devices (iPhone, iPad, Mac) -->
    <link rel="apple-touch-icon" type="image/jpeg" href="logo.jpeg">
    <link rel="apple-touch-icon" sizes="180x180" href="logo.jpeg">
    <!-- Android Chrome -->
    <link rel="android-chrome-icon" type="image/jpeg" href="logo.jpeg">
    <link rel="manifest" href="app.webmanifest">
    <style>
        @font-face {
            font-family: 'Söhne';
            src: url('https://cdn.openai.com/API/fonts/Sohne-Buch.woff2') format('woff2');
            font-weight: 400;
            font-style: normal;
        }
        @font-face {
            font-family: 'Söhne';
            src: url('https://cdn.openai.com/API/fonts/Sohne-Halbfett.woff2') format('woff2');
            font-weight: 600;
            font-style: normal;
        }
    *[title] {
        position: relative;
    }
    
    *[title]:hover::after {
        content: attr(title);
        position: absolute;
        background: rgba(100, 100, 100, 0.85);
        color: #fff;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 12px;
        white-space: normal;
        max-width: 150px;
        bottom: 130%;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10000;
        pointer-events: none;
        transition: all 0.2s ease;
        box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        line-height: 1.4;
    }

    body.dark-mode *[title]:hover::after {
        background: rgba(70, 70, 70, 0.9);
    }
    .custom-confirm-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.65);
        backdrop-filter: blur(2px);
        -webkit-backdrop-filter: blur(2px);
        z-index: 999999999;
        display: flex !important;
        align-items: center;
        justify-content: center;
        pointer-events: all !important;
    }
    .custom-confirm-box {
        position: relative;
        background: rgba(255,255,255,0.90);
        color: #111;
        border-radius: 8px;
        box-shadow: 0 4px 16px rgba(0,0,0,0.15);
        padding: 20px 24px;
        width: 300px;
        text-align: center;
        font-size: 14px;
        font-weight: 500;
        font-family: inherit;
        border: 0.5px solid rgba(0,0,0,0.1);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        pointer-events: all !important;
        z-index: 999999999;
    }
    .custom-confirm-buttons {
        margin-top: 16px;
        display: flex;
        gap: 12px;
        justify-content: center;
        position: relative;
        z-index: 999999999;
    }
    .custom-confirm-btn {
        padding: 6px 12px;
        border: none;
        border-radius: 4px;
        background: #f0f0f0;
        color: #111;
        font-size: 12px;
        cursor: pointer;
        position: relative;
        z-index: 999999999;
        pointer-events: all !important;
    }
    .custom-confirm-btn:hover {
        transform: translateY(-1px);
        background: #e0e0e0;
    }
    .custom-confirm-btn:active {
        transform: translateY(1px);
    }
    body.dark-mode .custom-confirm-box {
        background: rgba(32, 32, 32, 0.83);
        color: #eee;
        border: 0.5px solid rgba(70, 70, 70, 0.4);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
    }
    body.dark-mode .custom-confirm-btn {
        background: #444;
        color: #e0e0e0;
    }
    body.dark-mode .custom-confirm-btn:hover {
        background: #555;
    }
    .custom-confirm-btn:focus {
        outline: none;
    }
    .custom-confirm-btn:focus-visible {
        outline: none;
    }
    </style>
    <script>

    // Custom confirm modal for all links
    function customConfirm(message, url) {
        return new Promise((resolve) => {
            // Remove any existing modals
            const existingModals = document.querySelectorAll('.custom-confirm-modal');
            existingModals.forEach(modal => modal.remove());

            const modal = document.createElement('div');
            modal.className = 'custom-confirm-modal';
            modal.style.zIndex = '999999999';
            modal.innerHTML = `
                <div class="custom-confirm-box">
                    <div>${message}</div>
                    <div class="custom-confirm-buttons">
                        <button type="button" class="custom-confirm-btn yes" id="custom-confirm-yes">Yes</button>
                        <button type="button" class="custom-confirm-btn no" id="custom-confirm-no">No</button>
                    </div>
                </div>
            `;
            
            const cleanup = () => {
                modal.remove();
                document.removeEventListener('keydown', handleKeyboard);
                document.removeEventListener('click', handleModalClick);
            };

            const handleYes = (e) => {
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                cleanup();
                if (url) {
                    window.open(url, '_blank');
                }
                resolve(true);
            };

            const handleNo = (e) => {
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                cleanup();
                resolve(false);
            };

            const handleKeyboard = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleYes(e);
                }
                if (e.key === 'Escape') {
                    e.preventDefault();
                    handleNo(e);
                }
            };

            const handleModalClick = (e) => {
                if (e.target === modal) {
                    e.preventDefault();
                    handleNo(e);
                }
            };

            // Attach event listeners with proper cleanup
            const yesButton = modal.querySelector('#custom-confirm-yes');
            const noButton = modal.querySelector('#custom-confirm-no');
            
            yesButton.addEventListener('click', handleYes);
            noButton.addEventListener('click', handleNo);
            modal.addEventListener('click', handleModalClick);
            document.addEventListener('keydown', handleKeyboard);
            
            // Add modal to document
            document.body.appendChild(modal);
            
            // Focus Yes button
            requestAnimationFrame(() => {
                yesButton.focus();
            });
        });
    }

    // Get TradingView symbol - just use ticker directly, TradingView handles all exchanges
    function getTradingViewSymbol(ticker, exchange) {
        // TradingView can resolve any ticker symbol directly without exchange mapping
        console.log('getTradingViewSymbol:', { ticker, exchange });
        return ticker;
    }

    // Console filter to suppress DNS resolution logs for www.sec.gov
    (function() {
        const originalLog = console.log;
        const originalInfo = console.info;
        const originalWarn = console.warn;
        const originalError = console.error;

        function shouldFilter(message) {
            return typeof message === 'string' && message.includes('DNS resolved www.sec.gov');
        }

        console.log = function(...args) {
            if (!shouldFilter(args.join(' '))) {
                originalLog.apply(console, args);
            }
        };

        console.info = function(...args) {
            if (!shouldFilter(args.join(' '))) {
                originalInfo.apply(console, args);
            }
        };

        console.warn = function(...args) {
            if (!shouldFilter(args.join(' '))) {
                originalWarn.apply(console, args);
            }
        };

        console.error = function(...args) {
            if (!shouldFilter(args.join(' '))) {
                originalError.apply(console, args);
            }
        };
    })();
    </script>
    <script src="app.js"></script>
    <script>
        // Initialize global variables
        window.activeDropdown = null;
        window.dropdownStates = new Map();
        let clickTimeout = null;

        // Save dropdown states with positions
        function saveDropdownStates() {
            const openDropdowns = [];
            document.querySelectorAll('.score-breakdown').forEach(dropdown => {
                if (dropdown.style.display === 'block') {
                    const container = dropdown.closest('.score-details-container');
                    if (container) {
                        const alertCard = container.closest('.alert-card');
                        if (alertCard) {
                            const id = alertCard.getAttribute('data-ticker');
                            if (id) {
                                openDropdowns.push({
                                    id: id,
                                    top: dropdown.style.top,
                                    left: dropdown.style.left
                                });
                            }
                        }
                    }
                }
            });
            localStorage.setItem('openDropdowns', JSON.stringify(openDropdowns));
            return openDropdowns; // Return for immediate use
        }

        // Load dropdown states on page load or refresh
        function loadDropdownStates() {
            try {
                const savedDropdowns = JSON.parse(localStorage.getItem('openDropdowns')) || [];
                savedDropdowns.forEach(item => {
                    const alertCard = document.querySelector(`.alert-card[data-ticker="${item.id}"]`);
                    if (alertCard) {
                        const dropdown = alertCard.querySelector('.score-breakdown');
                        const button = alertCard.querySelector('.score-details-toggle');
                        if (dropdown && button) {
                            dropdown.style.display = 'block';
                            dropdown.style.top = item.top;
                            dropdown.style.left = item.left;
                            button.textContent = '▲';
                        }
                    }
                });
                return savedDropdowns; // Return for immediate use
            } catch (err) {
                console.error('Error loading dropdown states:', err);
                return [];
            }
        }
        
        // Preserve dropdown states during updates
        function preserveDropdownStates() {
            const states = saveDropdownStates();
            requestAnimationFrame(() => {
                states.forEach(item => {
                    const alertCard = document.querySelector(`.alert-card[data-ticker="${item.id}"]`);
                    if (alertCard) {
                        const dropdown = alertCard.querySelector('.score-breakdown');
                        const button = alertCard.querySelector('.score-details-toggle');
                        if (dropdown && button) {
                            dropdown.style.display = 'block';
                            dropdown.style.top = item.top;
                            dropdown.style.left = item.left;
                            button.textContent = '▲';
                        }
                    }
                });
            });
        }

        // Initialize dropdown state management
        document.addEventListener('DOMContentLoaded', loadDropdownStates);

        // Simplified version without mutation observer to prevent loops
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                preserveDropdownStates();
            }
        });

        // Handle clicks outside dropdowns
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.score-details-container')) {
                closeAllDropdowns();
                saveDropdownStates();
            }
        });

        function closeAllDropdowns() {
            document.querySelectorAll('.score-breakdown').forEach(dropdown => {
                if (dropdown.style.display === 'block') {
                    const button = dropdown.parentElement.querySelector('.score-details-toggle');
                    // Arrow removed
                    dropdown.style.display = 'none';
                }
            });
            activeDropdown = null;
            saveDropdownStates();
        }

        // Load dropdown states on page load
        window.addEventListener('load', function() {
            const savedDropdowns = localStorage.getItem('openDropdowns') ? JSON.parse(localStorage.getItem('openDropdowns')) : [];
            savedDropdowns.forEach(id => {
                const container = document.querySelector(`[data-id="${id}"]`);
                if (container) {
                    const dropdown = container.querySelector('.score-breakdown');
                    const button = container.querySelector('.score-details-toggle');
                    if (dropdown && button) {
                        dropdown.style.display = 'block';
                        button.textContent = '▲';
                        activeDropdown = dropdown;
                    }
                }
            });
        });

        function toggleDropdown(button, event) {
            // If button is invalid, return early
            if (!button) return;
            
            // Stop event propagation and prevent default
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            
            const container = button.closest('.score-details-container');
            if (!container) return;
            const dropdown = container.querySelector('.score-breakdown');
            if (!dropdown) return;

            // Close other dropdowns
            document.querySelectorAll('.score-breakdown').forEach(d => {
                if (d !== dropdown && d.style.display === 'block') {
                    d.style.display = 'none';
                    const btn = d.parentElement.querySelector('.score-details-toggle');
                    // Arrow removed
                }
            });

            // Toggle current dropdown
            if (dropdown.style.display === 'block') {
                dropdown.style.display = 'none';
                // Arrow removed
            } else {

                // Position and show the dropdown
                dropdown.style.position = 'absolute';
                dropdown.style.top = '25px';
                dropdown.style.right = '25px'; 
                dropdown.style.left = 'auto';
                dropdown.style.display = 'block';
                
                // Ensure the dropdown is visible and properly positioned
                requestAnimationFrame(() => {
                    const dropdownRect = dropdown.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;

                    // Check if dropdown extends beyond right edge
                    if (dropdownRect.right > viewportWidth) {
                        dropdown.style.right = '25px';
                        dropdown.style.left = 'auto';
                    }

                    // Check if dropdown extends beyond bottom edge
                    if (dropdownRect.bottom > viewportHeight) {
                        dropdown.style.top = 'auto';
                        dropdown.style.bottom = '25px';
                    }
                });
                button.textContent = '▲';
                
                // Handle clicks outside this dropdown
                const closeHandler = (e) => {
                    if (e && !container.contains(e.target) && !dropdown.contains(e.target)) {
                        dropdown.style.display = 'none';
                        // Arrow removed
                        document.removeEventListener('click', closeHandler);
                        document.removeEventListener('mouseleave', closeHandler);
                        saveDropdownStates();
                    }
                };
                
                // Remove any existing click handlers first
                document.removeEventListener('click', closeHandler);
                
                // Add the click handler on next tick to avoid immediate trigger
                requestAnimationFrame(() => {
                    document.addEventListener('click', closeHandler);
                    
                    // Keep dropdown open while hovering
                    dropdown.addEventListener('mouseover', function(e) {
                        e.stopPropagation();
                    });
                    
                    dropdown.addEventListener('mouseleave', function(e) {
                        if (!container.contains(e.relatedTarget)) {
                            closeHandler(e);
                        }
                    });
                });
            }

            saveDropdownStates();
            return false;
        }
    </script>
    <style>
        /* Link buttons */
        .link-button {
            background: rgba(240, 240, 240, 0.92);
            border: 1px solid #cccccc;
            padding: 4px 12px;
            border-radius: 3px;
            font-size: 11.5px;
            cursor: pointer;
            color: #333;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }

        body.dark-mode .link-button {
            background: rgba(45, 45, 45, 0.35);
            border: 1px solid rgba(85, 85, 85, 0.5);
            color: #e0e0e0;
            transition: all 0.2s ease;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }

        .score-details-toggle {
            background: transparent;
            border: none;
            outline: none;
            width: 26px;
            height: 26px;
            font-size: 18px;
            line-height: 1;
            text-align: center;
            color: #999;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0;
            position: absolute;
            top: 8px;
            right: 6px;
            min-height: unset;
            min-width: unset;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 1003;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            will-change: color, box-shadow, background-color;
            box-shadow: 0 0 0 transparent;
            pointer-events: auto !important;
        }

        .score-details-toggle:hover {
            color: #555;
            box-shadow: 0 0 0 2px rgba(100, 100, 100, 0.4), 0 0 8px rgba(100, 100, 100, 0.2) !important;
            pointer-events: auto !important;
            background-color: rgba(0, 0, 0, 0.08);
            padding: 0;
            border-radius: 4px;
            transition: all 0.2s ease;
            outline: none !important;
        }
        
        .score-details-toggle:focus {
            outline: none !important;
            box-shadow: 0 0 0 2px rgba(100, 100, 100, 0.4), 0 0 8px rgba(100, 100, 100, 0.2) !important;
        }

        body.dark-mode .score-details-toggle {
            color: #ccc;
        }

        body.dark-mode .score-details-toggle:hover {
            color: #aaa;
            box-shadow: 0 0 0 2px rgba(150, 150, 150, 0.4), 0 0 8px rgba(150, 150, 150, 0.2) !important;
            background-color: rgba(29, 155, 240, 0.12);
            padding: 0;
            border-radius: 4px;
            transition: all 0.2s ease;
            outline: none !important;
        }
        
        body.dark-mode .score-details-toggle:focus {
            outline: none !important;
            box-shadow: 0 0 0 2px rgba(29, 155, 240, 0.6), 0 0 8px rgba(29, 155, 240, 0.4) !important;
        }

        button {
            background: #f0f0f0;
            border: 1px solid #ccc;
            padding: 4px 12px;
            border-radius: 3px;
            font-size: 11.5px;
            cursor: pointer;
            position: relative;
            z-index: 3;
        }

        button:active {
            transform: translateY(1px);
        }

        body.dark-mode button {
            background: #333;
            border-color: #555;
            color: #e0e0e0;
        }
        
        .score-details-container {
            position: relative;
            pointer-events: all;
            z-index: 100;
        }
        .trigger-alert {
            background: rgba(240, 240, 240, 0.92) !important;
            color: #333 !important;
            border: 1px solid rgba(102, 102, 102, 0.5) !important;
            backdrop-filter: blur(4px) !important;
            -webkit-backdrop-filter: blur(4px) !important;
            box-shadow: none !important;
        }

        .trigger-alert:hover {
            background: rgba(228, 228, 228, 0.95) !important;
            border-color: #666 !important;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important;
        }

        body.dark-mode .trigger-alert {
            background: rgba(45, 45, 45, 0.35) !important;
            color: #e0e0e0 !important;
            border: 1px solid rgba(85, 85, 85, 0.5) !important;
        }

        .score-breakdown {
            display: none;
            position: absolute;
            top: 10px;
            right: 8px;
            z-index: 1001;
            background: rgba(255, 255, 255, 0.95);
            padding: 3px 5px;
            border-radius: 3px;
            box-shadow: none;
            width: 274px;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            transition: none;
            border: 1px solid #ddd;
            font-size: 5px;
            line-height: 1;
        }

        body.dark-mode .score-breakdown {
            background: rgba(42, 42, 42, 0.95);
            border: 1px solid rgba(68, 68, 68, 0.8);
            width: 274px;
        }

        /* Button and animation fixes */
        .score-details-toggle:active {
            transform: translateY(1px);
        }

        /* Button styling for triggered cards */
        body.dark-mode .alert-card.triggered.down .score-details-toggle {
            color: #ffcccc;
        }

        body.dark-mode .alert-card.triggered.up .score-details-toggle {
            color: #ccffcc;
        }

        body:not(.dark-mode) .alert-card.triggered.down .score-details-toggle {
            color: #8b0000;
        }

        body:not(.dark-mode) .alert-card.triggered.up .score-details-toggle {
            color: #008000;
        }

        @keyframes flash {
            0% { background: rgba(255, 25, 25, 0.75); }
            25% { background: rgba(255, 25, 25, 0.85); }
            50% { background: rgba(201, 12, 12, 0.75); }
            75% { background: rgba(235, 15, 15, 0.85); }
            100% { background: rgba(255, 25, 25, 0.75); }
        }

        @keyframes flashDark {
            0% { background: rgba(204, 0, 0, 0.85); }
            25% { background: rgba(179, 0, 0, 0.75); }
            50% { background: rgba(153, 0, 0, 0.85); }
            75% { background: rgba(179, 0, 0, 0.75); }
            100% { background: rgba(204, 0, 0, 0.85); }
        }

        .alert-card.triggered.down {
            animation: flash 3s ease-in-out infinite;
            color: #fff !important;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            transition: background 0.3s, color 0.3s;
            }
            body:not(.dark-mode) .alert-card.triggered.down {
                background: #fc2020 !important; /* Vibrant red for down cards in light mode only */
        }

        body.dark-mode .alert-card.triggered.down {
            animation: flashDark 3s ease-in-out infinite;
            /* No static background, let animation show multiple shades */
        }

        body {
            font-family: "Söhne", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: white;
            color: black;
            margin: 0;
            padding: 0;
            font-size: 12px;
            -webkit-font-smoothing: antialiased;
            transition: background-color 0.02s ease, color 0.02s ease;
            scrollbar-gutter: stable;
            overflow-y: scroll;
        }

        body.dark-mode {
            background: #1a1a1a;
            color: #e0e0e0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        @media (max-width: 768px) {
            .container {
                padding: 0 !important;
                margin: 0 !important;
                max-width: 100% !important;
                width: 100% !important;
            }
        }

        .header {
            padding-top: 10px;
            padding-bottom: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }

        .time-display {
            transition: background-color 0.3s, border-color 0.3s;
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 10px;
            color: #333333;
            text-align: right;
            display: flex;
            gap: 15px;
        }
        
        body.dark-mode .time-display {
            color: #ccc;
        }

        .separator {
            height: 0.25px;
            background: #c0c0c0;
            margin: 20px 0 5px 0;
        }

        body.dark-mode .separator {
            background: #444;
        }

        .header-top {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .theme-toggle {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 42px;
            height: 42px;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            margin: -3px 0 0 0;
        }

        .theme-toggle:hover {
            opacity: 0.8;
            transform: scale(1.05);
        }
        
        .theme-toggle svg {
            width: 30px;
            height: 30px;
            stroke: #333;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
            transition: stroke 0.3s ease;
        }

        .dark-mode .theme-toggle svg {
            stroke: #fff;
        }

        .header h1 {
            font-size: 20px;
            margin: 0;
            color: #666666;
            transition: color 0.15s ease;
            letter-spacing: -0.3px;
        }

        .header-top {
            display: flex;
            align-items: center;
            gap: 20px;
            width: 100%;
            margin-top: 10px;
            margin-bottom: 20px;
        }

        .logo {
            height: 100px;
            width: auto;
            transition: all 0.3s ease;
            object-fit: contain;
            border-radius: 4px;
        }

        body.dark-mode .logo {
            filter: invert(1);
        }

        body.dark-mode .dashboard-title {
            color: #ffffff !important;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
            width: 100%;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(120,120,120,0.15);
            padding-bottom: 20px;
        }
        
        .stat-box {
            border: 1px solid rgba(130,130,130,0.35);
            padding: 10.75px;
            text-align: center;
            background: #f8f8f8;
            border-radius: 4px;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        
        @media (max-width: 768px) {
            html, body {
                overflow-x: hidden !important;
                width: 100% !important;
                overflow-y: auto;
                font-size: 12px;
                max-width: 100vw;
            }
            
            .header {
                flex-direction: row;
                align-items: flex-start;
                padding: 6px 8px !important;
                margin-bottom: 10px !important;
                position: relative;
                justify-content: space-between;
                gap: 4px;
                flex-wrap: wrap;
            }
            
            .header-top {
                display: flex;
                align-items: center;
                gap: 6px;
                width: auto;
                margin: 0 !important;
                flex: 0 0 auto;
                justify-content: flex-start;
                order: 1;
            }
            
            .logo {
                height: 50px !important;
                width: auto !important;
                margin-right: 8px;
            }
            
            .dashboard-title {
                margin: 0 !important;
                font-size: 14px !important;
                white-space: nowrap;
                flex-shrink: 0;
            }
            
            .theme-toggle {
                position: absolute !important;
                right: 6px !important;
                top: 6px !important;
                width: 28px !important;
                height: 28px !important;
                margin: 0 !important;
                padding: 0 !important;
                flex-shrink: 0;
                z-index: 100;
            }
            
            .theme-toggle svg {
                width: 22px !important;
                height: 22px !important;
            }
            
            .header-right {
                display: flex !important;
                align-items: center;
                justify-content: flex-end;
                gap: 4px;
                position: static !important;
                right: auto !important;
                top: auto !important;
                white-space: nowrap;
                width: auto;
                margin: 0 !important;
                flex-wrap: nowrap;
                margin-top: 4px;
                order: 3;
            }
            
            .time-display {
                display: flex !important;
                position: static !important;
                top: auto !important;
                right: auto !important;
                font-size: 7px !important;
                gap: 3px !important;
                margin: 0 !important;
                text-align: left;
                justify-content: flex-start;
                flex-wrap: nowrap;
                order: unset;
                white-space: nowrap;
                overflow: hidden;
            }
            
            .notification-history-icon {
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                font-size: 16px !important;
                order: unset;
                width: 28px !important;
                height: 28px !important;
                flex-shrink: 0;
                margin-right: 8px !important;
            }
            
            .notification-history-icon svg {
                width: 18px !important;
                height: 18px !important;
            }
            
            .stat-box {
                min-width: 100%;
                padding: 8px !important;
                font-size: 11px !important;
            }
            
            .stat-box > div:first-child {
                font-size: 10px !important;
            }
            
            .stat-box > div:last-child {
                font-size: 11px !important;
                margin-top: 3px !important;
            }
            
            .stats {
                grid-template-columns: 1fr;
                gap: 6px !important;
                margin-bottom: 12px !important;
                padding-bottom: 12px !important;
                border-bottom: 0.5px solid rgba(120,120,120,0.15) !important;
            }
            
            .alert-card {
                margin-bottom: 8px !important;
                padding: 7px !important;
                font-size: 11px !important;
            }
            
            .score-breakdown {
                width: 75px !important;
                max-width: 75vw !important;
                padding: 2px 2px !important;
                font-size: 4.3px !important;
                right: 6px !important;
                top: 40px !important;
                max-height: 150px !important;
                overflow: hidden !important;
                overflow-y: hidden !important;
                position: absolute !important;
                z-index: 1002 !important;
                line-height: 1.1 !important;
            }
            
            .score-breakdown .score-item,
            .score-breakdown .section-header,
            .score-breakdown .intent-tag {
                font-size: 4.3px !important;
            }
            
            .score-breakdown .score-header {
                font-size: 5px !important;
            }
            
            .score-details-container {
                position: relative !important;
                overflow: visible !important;
            }
            
            /* Mobile popup styles */
            .popup-content {
                max-width: 95vw !important;
                width: 95vw !important;
                max-height: 85vh !important;
                padding: 4px !important;
            }
            
            .popup-content h3 {
                font-size: 9px !important;
                margin: 0 0 4px !important;
                padding-bottom: 2px !important;
            }
            
            .popup-details {
                grid-template-columns: 1fr !important;
                gap: 3px !important;
                margin-bottom: 3px !important;
            }
            
            .popup-section {
                padding: 2px !important;
            }
            
            .popup-section h4 {
                font-size: 7px !important;
                margin: 0 0 2px !important;
                padding: 1px 2px !important;
            }
            
            .popup-section p {
                font-size: 8px !important;
                margin: 2px 0 !important;
            }
            
            .popup-section pre {
                font-size: 8px !important;
                line-height: 1.2 !important;
                padding: 2px !important;
                margin: 2px 0 !important;
            }
            
            .popup-footer {
                gap: 4px !important;
                padding-top: 3px !important;
            }
            
            .popup-footer button {
                padding: 2px 4px !important;
                font-size: 7px !important;
            }
        }
        .stat-box > div:first-child {
            font-size: 15px;
        }
        .stat-box > div:last-child {
            font-size: 15px;
            font-weight: 500;
            margin-top: 4px;
        }
        #last-update {
            font-size: 14px !important;
            font-weight: 500;
        }

        body.dark-mode .stat-box {
            border-color: #444;
            background: #282828;
        }

        .status-online {
            color: #1cba00e5 !important; /* Neon green */
            font-size: 8px;
            font-weight: bold;
        }

        body.dark-mode .status-online {
            color: #39FF14 !important; /* Same neon green for both modes */
        }
        
        .alerts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 14px;
            margin-bottom: 20px;
        }
        
            .alert-card {
                border: 1px solid rgba(130,130,130,0.35);
                padding: 9.5px;
                background: #ffffff;
                backdrop-filter: blur(8px);
                -webkit-backdrop-filter: blur(8px);
                transition: box-shadow 0.2s ease;
                position: relative;
                z-index: 1;
                height: auto;
                overflow: visible;
                margin-bottom: 9.75px;
                border-radius: 4px;
                transform: translate3d(0,0,0);
                isolation: isolate;
                font-size: 12px;
            }

            .alert-card-content {
                transition: opacity 0.3s ease;
                position: relative;
                z-index: 1;
            }
            
            /* Ensure score details container stays above content */
            .score-details-container {
                position: relative;
                z-index: 2;
                isolation: isolate;
            }        .alert-card.triggered {
            z-index: 2;
        }

        .alert-card:hover {
            z-index: 900;
        }
        
        .alert-card.triggered:hover {
            z-index: 901;
        }
        
        .alert-card .score-details-container {
            z-index: 100;
        }

        body.dark-mode .alert-card {
            background: #2a2a2a;
            border-color: #555;
            transition: none;
        }
        
        .alert-card.triggered.up {
            animation: flashGreen 3s ease-in-out infinite;
            color: white;
            text-shadow: none;
        }

        .alert-card.triggered.down {
            animation: flash 3s ease-in-out infinite;
            color: white;
            text-shadow: 0 1px 2px rgba(255,255,255,0.3);
        }

        /* Ensure dropdown text stays BLACK in light mode for triggered cards */
        body:not(.dark-mode) .alert-card.triggered .score-breakdown {
            color: #000 !important;
        }
        
        body:not(.dark-mode) .alert-card.triggered .score-breakdown * {
            color: inherit !important;
        }
        
        body:not(.dark-mode) .alert-card.triggered .score-breakdown .score-item span:first-child {
            color: #000 !important;
        }

        body:not(.dark-mode) .alert-card.triggered .score-breakdown .section-header {
            color: #000 !important;
        }

        body:not(.dark-mode) .alert-card.triggered .score-breakdown .intent-tag {
            color: #000 !important;
        }

        body.dark-mode .alert-card.triggered.down {
            animation: flashDark 3s ease-in-out infinite;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.4);
        }

        body.dark-mode .alert-card.triggered.down .price-change {
            text-shadow: 0 0 1.5px rgba(255, 51, 51, 0.6), 0 0 4px rgb(147, 0, 0) !important;
        }

        .alert-card.triggered.down > *:not(.score-details-container):not([style*="margin-top: 2px"]):not(button) {
            opacity: 1 !important;
        }

        body.dark-mode .alert-card.triggered.up {
            animation: flashDarkGreen 3s ease-in-out infinite;
            color: #ffffff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.255);
        }

        body.dark-mode .alert-card.triggered.up .price-change {
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.6), 0 0 1px rgba(0, 255, 0, 0.6), 0 0 2px rgba(1, 152, 1, 0.807) !important;
        }

        body.dark-mode .alert-card[data-position="short"].triggered.up .price-change {
            color: #009400c3 !important;
            text-shadow: 0 1px 0.5px rgba(0, 0, 0, 0.5) !important;
        }

        body.dark-mode .alert-card[data-position="long"].triggered.up .price-change {
            color: #039b039b !important;
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.5) !important;
        }

        .trigger-alert {
            color: white;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 6px;
            border-radius: 3px;
            display: inline-block;
            margin-top: 6px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .score-breakdown {
            animation: none !important;
            pointer-events: auto !important;
        }

        .score-details-container {
            animation: none !important;
            z-index: 1001 !important;
        }

        body.dark-mode .alert-card.triggered.up {
            animation: flashDarkGreen 3s ease-in-out infinite;
            color: #ffffff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        body.dark-mode .alert-card.triggered.down {
            animation: flashDark 3s ease-in-out infinite;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.4);
        }

        @keyframes flashDark {
            0% { 
                background: rgba(230, 3, 3, 0.85);
                opacity: 1;
            }
            25% {
                background: rgba(202, 2, 2, 0.848);
                opacity: 1;
            }
            50% { 
                background: rgba(133, 2, 2, 0.85);
                opacity: 0.95;
            }
            75% {
                background: rgba(179, 0, 0, 0.75);
                opacity: 0.95;
            }
            100% { 
                background: rgba(158, 8, 8, 0.85);
                opacity: 1;
            }
        }

        @keyframes flashDarkGreen {
            0% {
                background: rgba(4, 221, 4, 0.85);
                opacity: 1;
            }
            25% {
                background: rgba(1, 206, 1, 0.799);
                opacity: 1;
            }
            50% {
                background: rgba(9, 193, 9, 0.85);
                opacity: 0.95;
            }
            75% {
                background: rgba(2, 160, 2, 0.882);
                opacity: 0.95;
            }
            100% {
                background: rgba(1, 199, 1, 0.901);
                opacity: 1;
            }
        }
        
        /* Alert card border colors based on position and performance */
        .alert-card {
            border-left: 4px solid #cccccc !important;  /* Gray border for all cards */
        }

        body.dark-mode .alert-card {
            border-left: 4px solid #666666 !important;  /* Darker gray for dark mode */
        }
        
        .ticker {
            font-weight: bold;
            font-size: 14px;
            pointer-events: none;
        }
        
        .price-change {
            transition: color 0.2s ease;
            font-weight: 600;
        }
        
        /* LONG positions: up = profit (green), down = loss (red) */
        .alert-card[data-position="long"] .price-change.positive,
        .alert-card[data-position="long"][data-change="up"] .price-change {
            color: #00a600 !important;  /* Green for profit on longs */
        }
        
        body.dark-mode .alert-card[data-position="long"] .price-change.positive {
            color: #03c303 !important;  /* Match short green for consistency */
        }
        
        .alert-card[data-position="long"] .price-change.negative,
        .alert-card[data-position="long"][data-change="down"] .price-change {
            color: #cc0000 !important;  /* Red for loss on longs */
        }
        
        /* SHORT positions: down = profit (green), up = loss (red) */
        .alert-card[data-position="short"] .price-change.positive,
        .alert-card[data-position="short"][data-change="down"] .price-change {
            color: #00aa00 !important;  /* Green for profit on shorts */
        }
        
        body.dark-mode .alert-card[data-position="short"] .price-change.positive {
            color: #03c303 !important;  /* Match long green */
        }
        
        .alert-card[data-position="short"] .price-change.negative,
        .alert-card[data-position="short"][data-change="up"] .price-change {
            color: #cc0000 !important;  /* Red for loss on shorts */
        }

        .price-change.neutral {
            color: #666666 !important;
        }

        /* Dark mode colors */
        body.dark-mode .price-change[data-change="up"],
        body.dark-mode .price-change.positive,
        body.dark-mode .price-change[data-change="up"] {
            color: #00aa00 !important; /* Green for up/positive */
            text-shadow: 0 0 1px rgba(0, 170, 0, 0.5);
        }
        
        body.dark-mode .price-change[data-change="down"],
        body.dark-mode .price-change.negative {
            color: #00aa00 !important;  /* Green for down in dark mode */
            text-shadow: 0 0 2px rgba(0, 170, 0, 0.3);
        }

        body.dark-mode .price-change.neutral {
            color: #cccccc !important;
            text-shadow: 0 0 2px rgba(255, 255, 255, 0.1);
        }

        .price-change.neutral {
            color: #666;
        }

        body.dark-mode .price-change.neutral {
            color: #999;
        }

        /* Dark mode - brighter colors */
        /* Price change colors for light mode */
        /* SHORT position: Green if down more than 20%, Red if up */
        .alert-card[data-position="short"] .price-change {
            color: #666666 !important;  /* Default gray */
        }
        
        .alert-card[data-position="short"] .price-change[data-percent^="-2"],
        .alert-card[data-position="short"] .price-change[data-percent^="-3"],
        .alert-card[data-position="short"] .price-change[data-percent^="-4"],
        .alert-card[data-position="short"] .price-change[data-percent^="-5"],
        .alert-card[data-position="short"] .price-change[data-percent^="-6"],
        .alert-card[data-position="short"] .price-change[data-percent^="-7"],
        .alert-card[data-position="short"] .price-change[data-percent^="-8"],
        .alert-card[data-position="short"] .price-change[data-percent^="-9"] {
            color: #00aa00 !important;  /* Green for shorts when down ≥20% */
        }
        
        .alert-card[data-position="short"] .price-change[data-percent^="+"]{
            color: #ff0000 !important;  /* Red for shorts when up */
        }

        /* LONG position: Green if up more than 20%, Red if down */
        .alert-card[data-position="long"] .price-change {
            color: #666666 !important;  /* Default gray */
        }
        
        .alert-card[data-position="long"] .price-change[data-percent^="2"],
        .alert-card[data-position="long"] .price-change[data-percent^="3"],
        .alert-card[data-position="long"] .price-change[data-percent^="4"],
        .alert-card[data-position="long"] .price-change[data-percent^="5"],
        .alert-card[data-position="long"] .price-change[data-percent^="6"],
        .alert-card[data-position="long"] .price-change[data-percent^="7"],
        .alert-card[data-position="long"] .price-change[data-percent^="8"],
        .alert-card[data-position="long"] .price-change[data-percent^="9"] {
            color: #00aa00 !important;  /* Green for longs when up ≥20% */
        }
        
        .alert-card[data-position="long"] .price-change[data-percent^="-"] {
            color: #ff0000 !important;  /* Red for longs when down */
        }

        /* Dark mode colors */
        body.dark-mode .alert-card[data-position="short"] .price-change[data-percent^="-2"],
        body.dark-mode .alert-card[data-position="short"] .price-change[data-percent^="-3"],
        body.dark-mode .alert-card[data-position="short"] .price-change[data-percent^="-4"],
        body.dark-mode .alert-card[data-position="short"] .price-change[data-percent^="-5"],
        body.dark-mode .alert-card[data-position="short"] .price-change[data-percent^="-6"],
        body.dark-mode .alert-card[data-position="short"] .price-change[data-percent^="-7"],
        body.dark-mode .alert-card[data-position="short"] .price-change[data-percent^="-8"],
        body.dark-mode .alert-card[data-position="short"] .price-change[data-percent^="-9"] {
            color: #00ff00 !important;  /* Bright green for shorts when down ≥20% */
        }
        
        body.dark-mode .alert-card[data-position="long"] .price-change[data-percent^="2"],
        body.dark-mode .alert-card[data-position="long"] .price-change[data-percent^="3"],
        body.dark-mode .alert-card[data-position="long"] .price-change[data-percent^="4"],
        body.dark-mode .alert-card[data-position="long"] .price-change[data-percent^="5"],
        body.dark-mode .alert-card[data-position="long"] .price-change[data-percent^="6"],
        body.dark-mode .alert-card[data-position="long"] .price-change[data-percent^="7"],
        body.dark-mode .alert-card[data-position="long"] .price-change[data-percent^="8"],
        body.dark-mode .alert-card[data-position="long"] .price-change[data-percent^="9"] {
            color: #00d000 !important;  /* Darker green for longs when up ≥20% */
        }
        
        body.dark-mode .alert-card[data-position="short"] .price-change[data-percent^="+"],
        body.dark-mode .alert-card[data-position="long"] .price-change[data-percent^="-"] {
            color: #ff3333 !important;  /* Bright red for losses */
        }
        
        body.dark-mode .alert-card .price-change {
            color: #999999 !important;  /* Default dark mode gray */
        }

        button {
            transition: all 0.2s ease;
            min-height: 24px;
            min-width: 80px;
        }

        body.dark-mode .score-item span.positive,
        body.dark-mode .score-item span.negative,
        body.dark-mode .score-item span.neutral {
            text-shadow: none;
        }

        /* Position and ticker styling with transparency */
        .position.short,
        .ticker.short {
            color: rgba(255, 0, 0, 0.811);  /* Red with 70% opacity */
            font-weight: bold;
            transition: color 0.15s ease;
        }

        .position.long,
        .ticker.long {
            color: rgba(1, 186, 1, 0.874);  /* Green with 70% opacity */
            font-weight: bold;
            transition: color 0.15s ease;
        }
        
        /* Light mode: black shadow for [LONG]/[SHORT] on triggered green cards */
        body:not(.dark-mode) .alert-card.triggered.up .ticker span {
            text-shadow: 0px 0px 2.5px rgba(0, 0, 0, 0.85) !important;
        }

        /* Light mode: black shadow for [SHORT] on triggered red cards */
        body:not(.dark-mode) .alert-card.triggered.down .ticker span {
            text-shadow: 0px 0px 2.5px rgba(0, 0, 0, 1) !important;
        }

        /* Dark mode: black shadow for [LONG]/[SHORT] on triggered green cards */
        body.dark-mode .alert-card.triggered.up .ticker span {
        text-shadow: 0px 0px 2.5px rgba(0, 0, 0, 0.85) !important;
}

        /* Dark mode: black shadow for [SHORT] on triggered red cards */
        body.dark-mode .alert-card.triggered.down .ticker span {
            text-shadow: 0px 0px 2.5px rgba(0, 0, 0, 0.85) !important;
        }

        /* Dark mode - brighter colors with transparency */
        body.dark-mode .position.short,
        body.dark-mode .ticker.short {
            color: rgba(252, 28, 28, 0.884);  /* Brighter red with 70% opacity */
            transition: color 0.15s ease;
        }

        body.dark-mode .position.long,
        body.dark-mode .ticker.long {
            color: rgba(0, 255, 0, 0.7);  /* Brighter green with 70% opacity */
            text-shadow: 0px 0px 2.5px rgba(0, 0, 0, 0.5) !important;
            transition: color 0.15s ease;
        }

        .volume-spike {
            background: #f4c778;
            color: #000;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 10.5px;
            font-weight: 500;
            transition: all 0.15s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }

        .alert-card.triggered .volume-spike {
            background: #ffd980;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }

        body.dark-mode .volume-spike {
            background: #f0b350;
            box-shadow: 0 1px 3px rgba(0,0,0,0.15);
        }
        
        /* Light mode flash animation */
                @keyframes flashGreen {
            0% {
                background: rgba(4, 221, 4, 0.85);
                opacity: 1;
            }
            25% {
                background: rgba(1, 206, 1, 0.799);
                opacity: 1;
            }
            50% {
                background: rgba(9, 193, 9, 0.85);
                opacity: 0.95;
            }
            75% {
                background: rgba(2, 160, 2, 0.882);
                opacity: 0.95;
            }
            100% {
                background: rgba(1, 199, 1, 0.901);
                opacity: 1;
            }
        }


            @keyframes flash {
                0% {
                    background: rgba(252, 20, 20, 0.85);
                    opacity: 1;
                }
                25% {
                    background: rgba(224, 15, 15, 0.8);
                    opacity: 0.98;
                }
                50% {
                    background: rgba(196, 10, 10, 0.85);
                    opacity: 0.95;
                }
                75% {
                    background: rgba(224, 15, 15, 0.8);
                    opacity: 0.97;
                }
                100% {
                    background: rgba(252, 20, 20, 0.85);
                    opacity: 1;
                }
            }
        @keyframes flashDark {
            0% {
                background: rgba(200, 10, 10, 0.85);
                opacity: 1;
            }
            25% {
                background: rgba(180, 15, 15, 0.8);
                opacity: 0.98;
            }
            50% {
                background: rgba(160, 10, 10, 0.85);
                opacity: 0.95;
            }
            75% {
                background: rgba(180, 15, 15, 0.8);
                opacity: 0.97;
            }
            100% {
                background: rgba(200, 10, 10, 0.85);
                opacity: 1;
            }
        }
        
            .timestamp {
                color: #ffffff;
                font-size: 10.5px;
                margin-bottom: 2px;
                transition: color 0.005s ease;
            }

            body.dark-mode .timestamp {
                color: #999;
            }

            .alerts-header {
                color: #666;
            }

            body.dark-mode .alerts-header {
                color: #999;
            }

            .alerts-container {
                margin: 2px 0;
                display: flex;
                flex-direction: column;
                gap: 2px;
            }            .price-alerts {
                color: #333;
                font-size: 11px;
                line-height: 1.4;
                background: rgba(0,0,0,0.05);
                padding: 6px 10px;
                border-radius: 6px;
                display: inline-block;
                width: 100%;
                box-sizing: border-box;
            }

            .position-info {
                font-weight: 500;
                margin-bottom: 3px;
            }

            .alert-info {
                opacity: 0.75;
                font-size: 10px;
            }

        .trigger-alert {
            background: rgba(230, 230, 230, 0.75);
            color: #333;
            padding: 2px 6px;
            border-radius: 3px;
            display: inline-block;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 4px;
            margin-bottom: 2px;
            border: 1px solid #ddd;
            transition: all 0.2s ease;
            height: auto;
            box-sizing: border-box;
            max-width: fit-content;
            line-height: 1.2;
        }
        
        body.dark-mode .trigger-alert {
            background: rgba(45, 45, 45, 0.35);
            color: #e0e0e0;
            border: 1px solid rgba(85, 85, 85, 0.5);
            min-height: 14px;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            transition: all 0.2s ease;
        }            .alert-label {
                opacity: 0.95;
                font-weight: 500;
            }

            .noise-alert {
                margin: 0;
            }

            body.dark-mode .trigger-alert {
                background: rgba(28, 41, 61, 0.65);
            }        body.dark-mode .price-alerts {
            color: #e0e0e0;
            background: rgba(255,255,255,0.05);
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
        }

        .modal-content {
            background-color: #1e1e1e;
            margin: 5% auto;
            padding: 0;
            border: 1px solid #888;
            width: 90%;
            height: 80%;
            border-radius: 8px;
            overflow: hidden;
            transition: background-color 0.3s;
        }

        body.dark-mode .modal-content {
            background-color: #2a2a2a;
        }

        .modal-header {
            padding: 10px;
            background: #2a2a2a;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .modal-close:hover {
            color: white;
        }

        .modal-iframe {
            width: 100%;
            height: calc(100% - 50px);
            border: none;
        }

        /* Notification styles */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.15);
            color: #000;
            padding: 14px 18px;
            border-radius: 6px;
            border: 1px solid rgba(224,224,224,0.15);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 2000;
            max-width: 320px;
            min-width: 260px;
            font-size: 13px;
            opacity: 0;
            transform: translateX(100%) skew(-1deg);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            font-weight: 500;
            margin-bottom: 16px;
            line-height: 1.4;
            letter-spacing: 0.2px;
        }

        .notification i,
        .notification a {
            color: inherit;
            text-decoration: none;
            transition: all 0.15s ease;
        }

        body.dark-mode .notification {
            background: rgba(28, 28, 28, 0.25);
            color: #e0e0e0;
            border-color: rgba(80, 80, 80, 0.15);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .notification.show {
            opacity: 1;
            transform: translateX(0) skew(-2deg);
        }

        .notification.success {
            border-left: 4px solid #00cc00;
            background: rgba(240, 255, 240, 0.15);
            color: #004400;
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
        }

        .notification.info {
            border-left: 4px solid #0088ee;
            background: rgba(240, 248, 255, 0.15);
            color: #003866;
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
        }

        .notification.error {
            border-left: 4px solid #ee0000;
            background: rgba(255, 240, 240, 0.15);
            color: #000000;
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
        }

        .notification.error i {
            color: #cc0000;
            font-weight: 600;
        }

        /* Alert popup styles */
        .alert-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }

        .popup-content {
            background: white;
            padding: 8px;
            border-radius: 8px;
            max-width: 450px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        }

        body.dark-mode .popup-content {
            background: #2a2a2a;
            color: #e0e0e0;
            border: 1px solid #444;
        }

        .popup-content h3 {
            margin: 0 0 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #eee;
            font-size: 15px;
        }

        body.dark-mode .popup-content h3 {
            border-bottom-color: #444;
        }

        .popup-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 6px;
            margin-bottom: 6px;
        }

        .popup-section {
            padding: 4px;
            border-radius: 6px;
        }

        body.dark-mode .popup-section {
            background: #333;
        }

        .popup-section h4 {
            margin: 0 0 4px;
            padding: 2px 4px;
            font-size: 10px;
            color: #666;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        body.dark-mode .popup-section h4 {
            color: #999;
        }

        .popup-section p {
            margin: 5px 0;
            font-size: 13px;
        }

        .popup-footer {
            display: flex;
            justify-content: flex-end;
            gap: 6px;
            padding-top: 6px;
            border-top: 1px solid #eee;
        }

        body.dark-mode .popup-footer {
            border-top-color: #444;
        }

        .popup-footer button {
            padding: 4px 8px;
            border: none;
            border-radius: 4px;
            background: #f0f0f0;
            cursor: pointer;
            font-size: 10px;
            min-width: unset;
            min-height: unset;
        }

        body.dark-mode .popup-footer button {
            background: #444;
            color: #e0e0e0;
        }

        .popup-footer button:hover {
            background: #e0e0e0;
        }

        body.dark-mode .popup-footer button:hover {
            background: #555;
        }

        body.dark-mode .notification.success {
            border-left: 4px solid #00ff00;
            background: rgba(0, 34, 0, 0.25);
            color: #27fb27;
            transition: all 0.15s ease;
        }

        body.dark-mode .notification.info {
            border-left: 4px solid #0099ff;
            background: rgba(0, 25, 51, 0.25);
            color: #66b3ff;
            transition: all 0.15s ease;
        }

        body.dark-mode .notification.error {
            border-left: 4px solid #ff0000;
            background: rgba(51, 0, 0, 0.25);
            color: #ff3333;
            transition: all 0.15s ease;
        }

        .score-details-container {
            position: absolute;
            top: 10px;
            right: 10px;
        }

            .score-breakdown .score-item {
                display: flex;
                justify-content: space-between;
                margin-bottom: 0;
                font-size: 9px;
                line-height: 1.25;
                padding: 2px 3px;
                border-bottom: 1px solid rgba(0,0,0,0.02);
            }

            .score-breakdown .score-item:last-child {
                border-bottom: none;
                padding-bottom: 0;
            }

            .score-breakdown .score-item span:first-child {
                font-weight: 500;
                flex: 1;
                margin-right: 4px;
                color: #000 !important;
            }
            
            body:not(.dark-mode) .alert-card.triggered .score-breakdown .score-item span:first-child {
                color: #000 !important;
            }
            
            .score-breakdown .score-item span:last-child {
                font-weight: bold;
                text-align: right;
            }
            
            .score-breakdown .score-item span.positive {
                color: #00aa00;
            }
            
            .score-breakdown .score-item span.negative {
                color: #cc0000;
            }
            
            .score-breakdown .score-item span.neutral {
                color: #666;
            }

        .score-breakdown .score-header {
            font-weight: bold;
            font-size: 9px;
            margin-bottom: 2px;
            padding-bottom: 2px;
            border-bottom: 1px solid rgba(0,0,0,0.06);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .score-breakdown .section-header {
            font-weight: 600;
            margin: 4px 0 2px;
            color: #000 !important;
            text-transform: uppercase;
            font-size: 7px;
            letter-spacing: 0.4px;
        }
        
        body:not(.dark-mode) .alert-card.triggered .score-breakdown .section-header {
            color: #000 !important;
        }

        .score-breakdown .intent-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin: 6px 0;
        }

        .score-breakdown .intent-tag {
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 9.2px;
            color: #333 !important;
            border: 1px solid #ccc;
        }

        body.dark-mode .score-breakdown {
            background: rgba(42, 42, 42, 0.88);
            border-color: rgba(68, 68, 68, 0.6);
            color: #ffffff;
            box-shadow: 0 2px 8px rgba(0,0,0,0.25);
        }


        body.dark-mode .score-breakdown .score-item {
            border-bottom-color: rgba(255,255,255,0.1);
        }

        body.dark-mode .score-breakdown .score-item span:first-child {
            color: #ffffff !important;
        }
        
        body.dark-mode .alert-card.triggered .score-breakdown .score-item span:first-child {
            color: #ffffff !important;
        }

        body.dark-mode .score-breakdown .score-header {
            border-bottom-color: #444;
            color: #ffffff;
        }

        body.dark-mode .score-breakdown .section-header {
            color: #ffffff !important;
        }

        body.dark-mode .score-breakdown .intent-tag {
            background: #333;
            color: #ffffff !important;
            border: 1px solid #555;
        }
        
        body.dark-mode .alert-card.triggered .score-breakdown .intent-tag {
            color: #ffffff !important;
        }

        .score-breakdown .signal-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .score-breakdown .signal-positive {
            background: #00aa00;
        }

        .score-breakdown .signal-neutral {
            background: #666;
        }

        .score-breakdown .signal-negative {
            background: #c70202;
        }

        button {
            background: rgba(240, 240, 240, 0.92);
            border: 1px solid #cccccc;
            padding: 4px 12px;
            border-radius: 3px;
            font-size: 11.5px;
            min-height: 22px;
            min-width: 55px;
            cursor: pointer;
            color: #333;
        }

        body.dark-mode button {
            background: rgba(45, 45, 45, 0.35);
            border: 1px solid #666666;
            color: #e0e0e0;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 24px;
            position: absolute;
            right: 88px;
            top: 12px;
            white-space: nowrap;
        }

        .time-display {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 11px;
            margin-right: 42px;
            font-family: Menlo, monospace;
        }
        
        .nav-divider {
            color: #666;
            margin: 0 4px;
            user-select: none;
        }
        
        body.dark-mode .nav-divider {
            color: #999;
        }

        .notification-history-icon {
            cursor: pointer;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            opacity: 0.7;
            transition: all 0.2s ease;
            transform: scale(1);
            border-radius: 70%;
        }
        
        .notification-history-icon svg {
            width: 24px;
            height: 24px;
            stroke: #333;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
            transition: stroke 0.3s ease;
        }
        
        body.dark-mode .notification-history-icon svg {
            stroke: #fff;
        }

        .notification-history-icon:hover {
            opacity: 1;
            transform: scale(1.08);
        }

        body.dark-mode .notification-history-icon:hover {
            opacity: 1;
            transform: scale(1.08);
        }

        .notification-history-icon:active {
            transform: scale(0.9);
        }

        body.dark-mode .notification-history-icon {
            opacity: 0.7;
        }

        body.dark-mode .notification-history-icon:hover {
            opacity: 1;
        }

        .notification-count {
            font-size: 10px;
            background: #666666;
            color: white;
            padding: 1px 4px;
            border-radius: 8px;
            min-width: 14px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: -2px;
        }

        body.dark-mode .notification-count {
            background: #444444;
        }

        .notification-panel {
            position: fixed;
            top: 70px;
            right: 20px;
            width: 315px;
            max-height: 80vh;
            background: rgba(255,255,255,0.40);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 9999;
            display: none;
            overflow-y: auto;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(224,224,224,0.4);
            padding-bottom: 8px;
        }
        
        @media (max-width: 768px) {
            .notification-panel {
                position: fixed !important;
                top: 125px !important;
                right: 8px !important;
                left: auto !important;
                bottom: auto !important;
                width: 90vw !important;
                max-width: 300px !important;
                max-height: 55vh !important;
                margin-top: 0 !important;
            }
        }

        .notification-tab {
            background: transparent !important;
            border: none !important;
            outline: none !important;
            cursor: pointer;
            font-weight: bold;
            padding: 0 !important;
            transition: all 0.2s ease;
            color: #999;
            box-shadow: none !important;
        }
        
        .notification-tab:focus,
        .notification-tab:focus-visible {
            outline: none !important;
            box-shadow: none !important;
            background: transparent !important;
        }

        .notification-tab.active {
            color: #000 !important;
        }

        body.dark-mode .notification-tab.active {
            color: #fff !important;
        }

        body.dark-mode .notification-tab {
            color: #999;
        }

        .notification-duration {
            font-size: 10px;
            color: #888;
            margin-left: 4px;
            display: inline-block;
            vertical-align: middle;
        }

        body.dark-mode .notification-duration {
            color: #999;
        }

        body.dark-mode .notification-panel {
            background: rgba(42,42,42,0.70);
            border-color: rgba(68,68,68,0.4);
            box-shadow: 0 2px 8px rgba(0,0,0,0.25);
        }

        .notification-panel-header {
            padding: 10px 15px;
            border-bottom: 1px solid rgba(0,0,0,0.1);
            font-weight: 500;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .notification-list {
            padding: 10px;
        }

        .notification-item {
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.2s ease, background-color 0.2s ease, color 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 4px;
            color: #222;
            border-bottom: 1px solid rgba(0,0,0,0.08);
        }
        
        .notification-item:last-child {
            border-bottom: none;
        }
        
        .notification-item:hover {
            background-color: rgba(200, 200, 200, 0.15);
        }
        
        body.dark-mode .notification-item:hover {
            background-color: rgba(100, 100, 100, 0.2);
        }

        .notification-content {
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        body.dark-mode .notification-item {
            color: #fff;
        }

        .notification-item.success .title {
            color: #00aa00;
        }

        .notification-item.error .title {

            color: #cc0000;
        }

        body.dark-mode .notification-item.success .title {
            color: #00ff00;
        }

        body.dark-mode .notification-item.error .title {
            color: #ff4040;
        }

        .notification-item .actions {
            display: flex;
            gap: 8px;
            margin-top: 4px;
        }

        .notification-item .action-btn {
            font-size: 11px;
            padding: 4px 8px;
            border-radius: 4px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            color: #666;
            text-decoration: none;
            transition: all 0.2s ease;
        }

        .notification-item .action-btn:hover {
            background: #e4e4e4;
            transform: translateY(-1px);
        }

        body.dark-mode .notification-item .action-btn {
            background: #333;
            border-color: #444;
            color: #ccc;
        }

        body.dark-mode .notification-item .action-btn:hover {
            background: #444;
        }

            .notification-time {
                font-size: 11px;
                color: #666;
                margin-top: 4px;
            }

            .notification-time.short {
                margin-top: 2px;
                font-size: 10px;
                color: #888;
            }

            body.dark-mode .notification-time,
            body.dark-mode .notification-time.short {
                color: #999;
            }        .clear-notifications {
            cursor: pointer;
            font-size: 12px;
            color: #666;
            padding: 2px 6px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .clear-notifications:hover {
            background: rgba(0,0,0,0.1);
        }

        body.dark-mode .clear-notifications {
            color: #999;
        }

        body.dark-mode .clear-notifications:hover {
            background: rgba(255,255,255,0.1);
        }
        </style>
</head>
<body>
        <div class="container">
            <div class="header">
                <div class="header-top">
                    <img src="logo.jpeg?t=${new Date().getTime()}" alt="Logo" class="logo" style="height: 100px; width: auto; transition: opacity 0.4s ease;" onload="this.style.opacity=1">
                    <h1 style="color: #2c2c2c; font-size: 19.5px; font-family: 'Monaco', monospace !important; margin-left: 7px; margin-top: 18px;" class="dashboard-title">Eugene's Non-Profit</h1>
                </div>
                <div class="theme-toggle" onmousedown="event.stopPropagation(); toggleTheme();">
                    <svg class="theme-icon-light" viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                    <svg class="theme-icon-dark" style="display: none;" viewBox="0 0 24 24">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                </div>
                <div class="header-right">
                    <div class="time-display" id="time-display">
                        <!-- Time will be populated here -->
                    </div>
                    <div class="notification-history-icon" onclick="toggleNotificationPanel()">
                        <span class="notification-count" id="notification-count">0</span>
                        <script>
                        // Function to format notification time
                        function formatNotificationTime(date) {
                            const now = new Date();
                            const diff = now - date;
                            const seconds = Math.floor(diff / 1000);
                            const minutes = Math.floor(seconds / 60);
                            const hours = Math.floor(minutes / 60);
                            const days = Math.floor(hours / 24);

                            if (days > 0) return days + 'd';
                            if (hours > 0) return hours + 'h';
                            if (minutes > 0) return minutes + 'm';
                            return seconds + 's';
                        }
                        </script>
                    </div>
                </div>
            </div>
            <script>
            </script>
            <div class="stats">
                <div class="stat-box">
                    <div>Active Positions:</div>
                    <div id="active-count">0 <span style="font-size: 11.5px;">(L:0 | S:0):</span></div>
                </div>
                <div class="stat-box">
                    <div>Weighted ROI:</div>
                    <div id="pl-count">0%</div>
                </div>
                <div class="stat-box">
                    <div id="market-status">Market Opens:</div>
                    <div id="last-update">--:--:--</div>
                </div>
                <div class="stat-box">
                    <div>Network Status:</div>
                    <div id="status" class="status-online">Online: <span id="online-users">1</span></div>
                </div>
            </div>
            <div class="separator"></div>
        <div id="alerts-container" class="alerts-grid">
            <!-- Alerts will be populated here -->
        </div>
    </div>

    <div class="notification-panel" id="notification-panel">
        <div class="notification-panel-header">
            <div style="display: flex; gap: 15px; flex: 1;">
                <button class="notification-tab active" onclick="switchNotificationTab('recent')">Recent</button>
                <button class="notification-tab" onclick="switchNotificationTab('history')">History</button>
                <button class="notification-tab" onclick="switchNotificationTab('inbox')">Inbox</button>
            </div>
            <span class="clear-notifications" onclick="clearNotifications()">Clear All</span>
        </div>
        <div class="notification-list" id="notification-list">
            <!-- Recent alerts will be populated here -->
        </div>
        <div class="notification-list" id="notification-history-list" style="display: none;">
            <!-- History alerts will be populated here -->
        </div>
        <div class="notification-list" id="notification-inbox-list" style="display: none;">
            <!-- Inbox messages will be populated here -->
        </div>
    </div>

    <script>
        // Function to identify short setups
        function isShortSetup(alert) {
            // First check if alert has isShort or short property set
            if (alert.isShort === true || alert.short === true) return true;
            if (alert.isShort === false || alert.short === false) return false;
            
            if (!alert || !alert.intent) return false;
            
            // Check for primary short signals
            const hasReverseSplit = alert.intent.includes("Reverse Split");
            const hasBankruptcy = alert.intent.includes("Bankruptcy/Insolvency");
            const hasDilution = alert.intent.includes("Dilution");
            const hasGoingPrivate = alert.intent.includes("Going Private");
            
            // Short setup conditions in order of priority
            if (hasBankruptcy) return true; // Bankruptcy is always a short
            if (hasGoingPrivate) return true; // Going private low-ball offer is always a short
            if (hasReverseSplit && hasDilution) return true; // Reverse split + dilution combo
            if (hasReverseSplit) return true; // Any reverse split
            if (hasDilution && alert.intent.length === 1) return true; // Pure dilution with no other bullish signals
            
            // Consider a combination of dilution with other bearish signals
            if (hasDilution && alert.intent.some(signal => 
                signal.includes("Desperation") || 
                signal.includes("Bankruptcy") || 
                signal.includes("Insolvency"))) {
                return true;
            }
            
            return false;
        }

        // Function to calculate PnL
        function calculatePnL(alert) {
            if (!alert || !alert.ticker || !alert.alertPrice || !alert.currentPrice) return 0;
            
            let entryPrice = Number(alert.alertPrice);
            let currentPrice = Number(alert.currentPrice);
            
            if (isNaN(entryPrice) || isNaN(currentPrice) || entryPrice <= 0 || currentPrice <= 0) return 0;
            
            // Use performance.adjustedPercent (P&L) if available; otherwise calculate with reverse split detection
            let returnPercent = null;
            if (alert.performance && typeof alert.performance.adjustedPercent === 'number') {
                returnPercent = alert.performance.adjustedPercent;
            } else {
                // Check if reverse split ratio is stored in alert
                let reverseSplitRatio = alert.reverseSplitRatio;
                
                // If stored ratio is valid and > 1, use it
                if (reverseSplitRatio && reverseSplitRatio > 1) {
                    // Use stored ratio from quote.json
                } else if (!reverseSplitRatio) {
                    // If no stored ratio but prices suggest a split, auto-detect
                    const priceRatio = currentPrice / entryPrice;
                    
                    // Common reverse split ratios: detect if ratio matches 100:1, 50:1, 20:1, 10:1, 5:1, 2:1
                    // For SHORT positions, price goes UP after reverse split, so ratio > 1
                    if (priceRatio > 2.5 && priceRatio < 10) reverseSplitRatio = 100;  // HIGH ratio (3-5x suggests 100:1)
                    else if (priceRatio >= 10 && priceRatio < 20) reverseSplitRatio = 50;   // ~50:1 split
                    else if (priceRatio >= 20 && priceRatio < 30) reverseSplitRatio = 20;   // ~20:1 split
                    else if (priceRatio >= 30 && priceRatio < 50) reverseSplitRatio = 10;   // ~10:1 split
                    else if (priceRatio >= 50 && priceRatio < 100) reverseSplitRatio = 5;   // ~5:1 split
                    else if (priceRatio >= 100) reverseSplitRatio = 2;  // >100x ratio suggests 2:1
                }
                
                // If reverse split detected/stored, adjust entry price to post-split basis
                if (reverseSplitRatio && reverseSplitRatio > 1) {
                    const adjustedEntryPrice = entryPrice * reverseSplitRatio;
                    const isShortForCalc = Array.isArray(alert.isShort) ? alert.isShort.length > 0 : (alert.isShort === true);
                    
                    if (isShortForCalc) {
                        // SHORT: profit when price falls
                        returnPercent = ((adjustedEntryPrice - currentPrice) / adjustedEntryPrice) * 100;
                    } else {
                        // LONG: profit when price rises
                        returnPercent = ((currentPrice - adjustedEntryPrice) / adjustedEntryPrice) * 100;
                    }
                } else {
                    // No reverse split, calculate normally
                    returnPercent = ((currentPrice - entryPrice) / entryPrice) * 100;
                    const isShortForCalc = Array.isArray(alert.isShort) ? alert.isShort.length > 0 : (alert.isShort === true);
                    if (isShortForCalc) returnPercent = -returnPercent;
                }
            }
            
            const priceChangeElement = document.querySelector(`[data-ticker="${alert.ticker}"] .price-change`);
            
            if (priceChangeElement) {
                // Detect if short: check isShort array or position field
                const isShort = Array.isArray(alert.isShort) ? alert.isShort.length > 0 : (alert.position === 'short' || alert.isShort === true);
                const isDarkMode = document.body.classList.contains('dark-mode');
                
                if (isShort) {
                    // For shorts: negative price change is profit, positive change is loss
                    if (returnPercent > 0) {
                        priceChangeElement.style.color = isDarkMode ? '#ff3333' : '#ff0000';  // Red for loss
                    } else {
                        priceChangeElement.style.color = isDarkMode ? '#1fff1f' : '#00aa00';  // Green for profit
                    }
                    return returnPercent;  // For P&L, returnPercent is signed appropriately for shorts
                } else {
                    // For longs: positive change is profit, negative change is loss
                    if (returnPercent > 0) {
                        priceChangeElement.style.color = isDarkMode ? '#1fff1f' : '#00aa00';  // Green for profit
                    } else {
                        priceChangeElement.style.color = isDarkMode ? '#ff3333' : '#ff0000';  // Red for loss
                    }
                    return returnPercent;
                }
            }
            
            return 0;
        }

        // Utility functions for alerts
        function formatAlertAge(alertTime) {
            if (!alertTime) return 'Unknown';
            const now = new Date();
            const diff = now - alertTime;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (days > 0) return `${days}d ago`;
            if (hours > 0) return `${hours}h ago`;
            return `${minutes}m ago`;
        }

        function getLocationDisplay(location) {
            if (!location) return 'Unknown';
            const country = getCountryForFlag(location);
            const flag = COUNTRY_FLAG_MAP[country] || '';
            return `${flag} ${location}`;
        }

        function getMarketTimeWindow(date) {
            const nyDate = new Date(date.toLocaleString('en-US', { timeZone: 'America/New_York' }));
            const hours = nyDate.getHours();
            const minutes = nyDate.getMinutes();
            const time = hours * 100 + minutes;

            if (time < 930) return 'Pre-Market';
            if (time >= 930 && time <= 1600) return 'Market Hours';
            return 'After Hours';
        }

        function updateTimeDisplay() {
            const now = new Date();
            const nyTime = new Intl.DateTimeFormat('en-US', {
                timeZone: 'America/New_York',
                hour: 'numeric',
                minute: 'numeric',
                second: 'numeric',
                hour12: true
            }).format(now);
            document.getElementById('time-display').textContent = nyTime + ' ET';
        }

        // Notification functions
        function toggleNotificationPanel(event) {
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            const panel = document.getElementById('notification-panel');
            const isVisible = panel.style.display === 'block';

            // Only load alerts when opening, don't close dropdowns
            if (!isVisible) {
                loadRecentAlerts();
            }

            // Toggle panel visibility with animation
            if (!isVisible) {
                panel.style.display = 'block';
                panel.style.opacity = '0';
                panel.style.transform = 'translateY(-10px)';
                requestAnimationFrame(() => {
                    panel.style.opacity = '1';
                    panel.style.transform = 'translateY(0)';
                });
            } else {
                panel.style.opacity = '0';
                panel.style.transform = 'translateY(-10px)';
                setTimeout(() => {
                    panel.style.display = 'none';
                }, 200);
            }

            // Handle outside clicks
            if (!isVisible) {
                setTimeout(() => {
                    document.addEventListener('click', closeNotificationPanelOnClickOutside);
                }, 0);
            } else {
                document.removeEventListener('click', closeNotificationPanelOnClickOutside);
            }
        }

        function closeNotificationPanelOnClickOutside(event) {
            const panel = document.getElementById('notification-panel');
            const icon = document.querySelector('.notification-history-icon');
            if (!panel.contains(event.target) && !icon.contains(event.target)) {
                panel.style.display = 'none';
                document.removeEventListener('click', closeNotificationPanelOnClickOutside);
            }
        }

        function clearNotifications() {
            customConfirm('Clear all alerts?', null).then(confirmed => {
                if (confirmed) {
                    // Send request to clear alerts on server
                    fetch('/api/clear-alerts', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    }).then(res => res.json()).then(data => {
                        // Clear all notification lists
                        const recentList = document.getElementById('notification-list');
                        const historyList = document.getElementById('notification-history-list');
                        const inboxList = document.getElementById('notification-inbox-list');
                        
                        [recentList, historyList, inboxList].forEach(list => {
                            list.innerHTML = '';
                            const emptyState = document.createElement('div');
                            emptyState.style.cssText = 'padding: 20px; text-align: center; opacity: 0.6; font-size: 12px;';
                            emptyState.textContent = 'No alerts';
                            list.appendChild(emptyState);
                        });
                        
                        // Clear local storage
                        localStorage.removeItem('recentAlerts');
                        localStorage.removeItem('alertHistory');
                        
                        // Reload the page after 200ms to refresh everything
                        setTimeout(() => {
                            location.reload();
                        }, 200);
                    }).catch(err => console.error('Error clearing alerts:', err));
                }
            });
        }

        function switchNotificationTab(tab) {
            const recentList = document.getElementById('notification-list');
            const historyList = document.getElementById('notification-history-list');
            const inboxList = document.getElementById('notification-inbox-list');
            const tabs = document.querySelectorAll('.notification-tab');
            
            tabs.forEach(t => {
                t.classList.remove('active');
                t.style.color = '#999';
            });
            
            if (tab === 'recent') {
                recentList.style.display = 'block';
                historyList.style.display = 'none';
                inboxList.style.display = 'none';
                tabs[0].classList.add('active');
                tabs[0].style.color = '';
                loadRecentAlerts();
            } else if (tab === 'history') {
                recentList.style.display = 'none';
                historyList.style.display = 'block';
                inboxList.style.display = 'none';
                tabs[1].classList.add('active');
                tabs[1].style.color = '';
                loadHistoryAlerts();
            } else if (tab === 'inbox') {
                recentList.style.display = 'none';
                historyList.style.display = 'none';
                inboxList.style.display = 'block';
                tabs[2].classList.add('active');
                tabs[2].style.color = '';
                loadInboxMessages();
            }
        }

        function loadRecentAlerts() {
            const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            const alertUrl = isLocalhost ? '/logs/alert.json' : 'https://raw.githubusercontent.com/heyitshurberto/sysd/main/logs/alert.json';
            
            fetch(alertUrl)
                .then(r => r.json())
                .then(alerts => {
                    const list = document.getElementById('notification-list');
                    list.innerHTML = '';
                    
                    if (!alerts || !Array.isArray(alerts) || alerts.length === 0) {
                        const emptyState = document.createElement('div');
                        emptyState.style.cssText = 'padding: 20px; text-align: center; opacity: 0.6; font-size: 12px;';
                        emptyState.textContent = 'No recent alerts';
                        list.appendChild(emptyState);
                        // Update notification count even if no alerts
                        updateNotificationCount();
                        return;
                    }
                    
                    // Update notifications array for badge count
                    notifications = alerts;
                    updateNotificationCount();
                    
                    alerts.slice(-20).reverse().forEach(alert => {
                        const item = document.createElement('div');
                        item.className = 'notification-item';
                        item.style.cursor = 'pointer';
                        const date = new Date(alert.recordedAt);
                        const dateStr = date.toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: '2-digit' });
                        const timeStr = date.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                        const floatStr = alert.float && alert.float !== 'N/A' ? (alert.float / 1000000).toFixed(2) + 'm' : 'N/A';
                        const soStr = alert.soRatio || 'N/A';
                        let insiderStr = 'N/A';
                        if (alert.insiderPercent && alert.insiderPercent !== 'N/A') {
                            const insiderVal = parseFloat(alert.insiderPercent) * 100;
                            insiderStr = !isNaN(insiderVal) ? insiderVal.toFixed(2) + '%' : 'N/A';
                        }
                        
                        const secLink = `https://www.sec.gov/cgi-bin/browse-edgar?action=getcompany&CIK=${alert.cik}&type=6-K&dateb=&owner=exclude&count=100`;
                        const saLink = `https://www.stockanalysis.com/stocks/${alert.ticker.toLowerCase()}/`;
                        
                        item.innerHTML = `
                            <div style="font-weight: 650; margin-bottom: 8px;">$${alert.ticker} @ $${alert.price}</div>
                            <div style="font-size: 11px; opacity: 0.77; margin-bottom: 4px;">Score: ${alert.signalScore.toFixed(2)} | Float: ${floatStr} | S/O: ${soStr}</div>
                            <div style="margin-top: 2px; font-size: 10px; opacity: 0.5;">${dateStr} ${timeStr}</div>
                        `;
                        
                        item.addEventListener('click', () => {
                            customConfirm(`View details for $${alert.ticker}?`, `${saLink}`);
                        });
                        
                        list.appendChild(item);
                    });
                })
                .catch(e => {
                    console.error('No recent alerts:', e);
                    const list = document.getElementById('notification-list');
                    list.innerHTML = '';
                    const emptyState = document.createElement('div');
                    emptyState.style.cssText = 'padding: 20px; text-align: center; opacity: 0.6; font-size: 12px;';
                    emptyState.textContent = 'No recent alerts';
                    list.appendChild(emptyState);
                    // Update notification count even on error
                    updateNotificationCount();
                });
        }

        function loadHistoryAlerts() {
            const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            const stockUrl = isLocalhost ? '/logs/stocks.json' : 'https://raw.githubusercontent.com/heyitshurberto/sysd/main/logs/stocks.json';
            
            fetch(stockUrl)
                .then(r => r.json())
                .then(stocks => {
                    const list = document.getElementById('notification-history-list');
                    list.innerHTML = '';
                    
                    if (!stocks || !Array.isArray(stocks) || stocks.length === 0) {
                        const emptyState = document.createElement('div');
                        emptyState.style.cssText = 'padding: 20px; text-align: center; opacity: 0.6; font-size: 12px;';
                        emptyState.textContent = 'No history available';
                        list.appendChild(emptyState);
                        return;
                    }
                    
                    stocks.slice(-2).reverse().forEach(stock => {
                        const item = document.createElement('div');
                        item.className = 'notification-item';
                        item.style.cursor = 'pointer';
                        const date = new Date(stock.recordedAt);
                        const dateStr = date.toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: '2-digit' });
                        const timeStr = date.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                        const floatStr = stock.float && stock.float !== 'N/A' ? (stock.float / 1000000).toFixed(2) + 'm' : 'N/A';
                        const soStr = stock.soRatio || 'N/A';
                        const insiderStr = stock.insiderPercent !== 'N/A' ? (stock.insiderPercent * 100).toFixed(2) + '%' : 'N/A';
                        
                        const exchange = stock.exchange || 'NASDAQ';
                        const saLink = `https://www.stockanalysis.com/stocks/${stock.ticker.toLowerCase()}/`;
                        
                        item.innerHTML = `
                            <div style="font-weight: 650; margin-bottom: 4px;">$${stock.ticker} @ $${stock.price}</div>
                            <div style="font-size: 10px; opacity: 0.5;">Alert Time: ${dateStr} ${timeStr}</div>
                        `
                        
                        item.addEventListener('click', () => {
                            customConfirm(`View details for $${stock.ticker}?`, saLink);
                        });
                        
                        list.appendChild(item);
                    });
                })
                .catch(e => {
                    console.error('No available history:', e);
                    const list = document.getElementById('notification-history-list');
                    list.innerHTML = '';
                    const emptyState = document.createElement('div');
                    emptyState.style.cssText = 'padding: 20px; text-align: center; opacity: 0.6; font-size: 12px;';
                    emptyState.textContent = 'No available history';
                    list.appendChild(emptyState);
                });
        }

        function loadInboxMessages() {
            const list = document.getElementById('notification-inbox-list');
            list.innerHTML = '';
            
            const messages = JSON.parse(localStorage.getItem('inbox-messages')) || [];
            
            if (messages.length === 0) {
                const emptyState = document.createElement('div');
                emptyState.style.cssText = 'padding: 20px; text-align: center; opacity: 0.6; font-size: 12px;';
                emptyState.textContent = 'No messages';
                list.appendChild(emptyState);
                return;
            }
            
            messages.slice().reverse().forEach((msg, idx) => {
                const item = document.createElement('div');
                item.className = 'notification-item';
                item.style.cssText = 'position: relative; padding: 10px; border: 1px solid rgba(0,0,0,0.1); margin-bottom: 8px;';
                
                const msgDate = new Date(msg.timestamp);
                const timeStr = msgDate.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
                const dateStr = msgDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                
                item.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: start;">
                        <div style="flex: 1; cursor: pointer;">
                            <div style="font-weight: 600; margin-bottom: 4px;">${msg.title}</div>
                            <div style="font-size: 12px; opacity: 0.8; margin-bottom: 6px;">${msg.message}</div>
                            <div style="font-size: 10px; opacity: 0.6;">${dateStr} at ${timeStr}</div>
                        </div>
                        <button onclick="deleteInboxMessage(${messages.length - 1 - idx})" style="background: none; border: none; color: #999; cursor: pointer; font-size: 16px; padding: 0; margin-left: 8px;">×</button>
                    </div>
                `;
                
                item.addEventListener('click', (e) => {
                    if (e.target.textContent !== '×' && !e.target.closest('button')) {
                        editInboxMessage(messages.length - 1 - idx);
                    }
                });
                
                list.appendChild(item);
            });
            
            const addBtn = document.createElement('div');
            addBtn.style.cssText = 'padding: 10px; text-align: center; border-top: 1px solid rgba(0,0,0,0.1); margin-top: 10px;';
            addBtn.innerHTML = `<button onclick="createNewMessage()" style="background: #0066cc; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 12px;">+ New Message</button>`;
            list.appendChild(addBtn);
        }

        function createNewMessage() {
            const title = prompt('Message title:');
            if (!title) return;
            
            const message = prompt('Message content:');
            if (!message) return;
            
            const messages = JSON.parse(localStorage.getItem('inbox-messages')) || [];
            messages.push({
                title: title,
                message: message,
                timestamp: new Date().toISOString()
            });
            localStorage.setItem('inbox-messages', JSON.stringify(messages));
            loadInboxMessages();
        }

        function editInboxMessage(idx) {
            const messages = JSON.parse(localStorage.getItem('inbox-messages')) || [];
            if (idx < 0 || idx >= messages.length) return;
            
            const msg = messages[idx];
            const newTitle = prompt('Edit title:', msg.title);
            if (newTitle === null) return;
            
            const newMessage = prompt('Edit message:', msg.message);
            if (newMessage === null) return;
            
            messages[idx].title = newTitle;
            messages[idx].message = newMessage;
            localStorage.setItem('inbox-messages', JSON.stringify(messages));
            loadInboxMessages();
        }

        function deleteInboxMessage(idx) {
            if (!confirm('Delete this message?')) return;
            
            const messages = JSON.parse(localStorage.getItem('inbox-messages')) || [];
            messages.splice(idx, 1);
            localStorage.setItem('inbox-messages', JSON.stringify(messages));
            loadInboxMessages();
        }

        function addToNotificationHistory(message, type, link) {
            const notificationList = document.getElementById('notification-list');
            const notificationCount = document.getElementById('notification-count');
            
            const item = document.createElement('div');
            item.className = 'notification-item';
            const now = new Date();
            const dateStr = now.toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: '2-digit' });
            const timeStr = now.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit' });
            item.innerHTML = `
                <div class="notification-content">
                    <div class="title">${message}</div>
                    <div class="time" style="margin-top: 2px; font-size: 10px; opacity: 0.5;">${dateStr} ${timeStr}</div>
                </div>
            `;
            
            notificationList.insertBefore(item, notificationList.firstChild);
            
            // Keep notification history limited to 100 items to prevent unbounded growth
            const items = notificationList.querySelectorAll('.notification-item');
            if (items.length > 100) {
                items[items.length - 1].remove();
            }
            
            notificationCount.textContent = Math.min(parseInt(notificationCount.textContent) + 1, items.length);
        }

        // Play sound based on alert level
        function playTieredAlert(priceChange) {
            // You can implement sound playing logic here if needed
            console.log(`Would play sound for ${priceChange} price change`);
        }

        const SEC_CODE_TO_COUNTRY = {
            'A1': 'Toronto, Canada', '1T': 'Athens, Greece', 'A6': 'Toronto, Canada', 'A9': 'Vancouver, Canada', 'B2': 'Bridgetown, Barbados', 'B6': 'Nassau, Bahamas', 'B9': 'Hamilton, Bermuda', 'C0': 'Cayman Islands', 'C1': 'Buenos Aires, Argentina', 'C2': 'Shanghai, China', 'C3': 'Brisbane, Australia', 'C4': 'Toronto, Canada', 'C7': 'St. Helier, Channel Islands', 'D0': 'Hamilton, Canada', 'D2': 'Hamilton, Bermuda', 'D4': 'Hamilton, Bermuda', 'D5': 'Sao Paulo, Brazil', 'D6': 'Bridgetown, Barbados', 'D8': 'Hong Kong', 'D9': 'Toronto, Canada', 'DE': 'Wilmington, Delaware', 'E4': 'Hamilton, Bermuda', 'E5': 'Dublin, Ireland', 'F2': 'Frankfurt, Germany', 'F3': 'Paris, France', 'F4': 'Shadong, China', 'F5': 'Johannesburg, South Africa', 'G0': 'St. Helier, Jersey', 'G1': 'St. Peter Port, Guernsey', 'G4': 'New York, United States', 'G7': 'Copenhagen, Denmark', 'H0': 'Hong Kong', 'H1': 'St. Helier, Jersey', 'I0': 'Dublin, Ireland', 'I1': 'Douglas, Isle of Man', 'J0': 'St. Helier, Jersey', 'J1': 'Tokyo, Japan', 'J2': 'St. Helier, Jersey', 'J3': 'St. Helier, Jersey', 'K1': 'Seoul, South Korea', 'K2': 'Cayman Islands', 'K7': 'New York, United States', 'L0': 'Hamilton, Bermuda', 'L2': 'Dublin, Ireland', 'L3': 'Tel Aviv, Israel', 'L6': 'Milan, Italy', 'M0': 'Tokyo, Japan', 'M1': 'Majuro, Marshall Islands', 'N0': 'Amsterdam, Netherlands', 'N2': 'Amsterdam, Netherlands', 'N4': 'Amsterdam, Netherlands', 'O5': 'Mexico City, Mexico', 'P0': 'Lisbon, Portugal', 'E9': 'Cayman Islands', 'P3': 'Manila, Philippines', 'P7': 'Madrid, Spain', 'P8': 'Warsaw, Poland', 'Q0': 'Toronto, Canada', 'R0': 'Milan, Italy', 'S0': 'Madrid, Spain', 'S4': 'Singapore', 'T0': 'Lisbon, Portugal', 'T3': 'Johannesburg, South Africa', 'U0': 'Singapore', 'U1': 'London, United Kingdom', 'U5': 'London, United Kingdom', 'V0': 'Zurich, Switzerland', 'V8': 'Geneva, Switzerland', 'VI': 'Road Town, British Virgin Islands', 'W0': 'Frankfurt, Germany', 'X0': 'London, UK', 'X1': 'Luxembourg City, Luxembourg', 'Y0': 'Nicosia, Cyprus', 'Y1': 'Nicosia, Cyprus', 'Z0': 'Johannesburg, South Africa', 'Z1': 'Johannesburg, South Africa', '1A': 'Pago Pago, American Samoa', '1B': 'Saipan, Northern Mariana Islands', '1C': 'Hagatna, Guam', '1D': 'San Juan, Puerto Rico', '1E': 'Charlotte Amalie, U.S. Virgin Islands', '3A': 'Sydney, Australia', '4A': 'Auckland, New Zealand', '5A': 'Apia, Samoa', '6A': 'Shanghai, China', '7A': 'Moscow, Russia', '8A': 'Mumbai, India', '9A': 'Jakarta, Indonesia', '2M': 'Frankfurt, Germany', 'U3': 'Madrid, Spain', 'Y9': 'Nicosia, Cyprus', 'CA': 'Toronto, Canada', 'AL': 'Birmingham, UK', 'Q8': 'Oslo, Norway', 'R1': 'Panama City, Panama', 'V7': 'Stockholm, Sweden', 'A0': 'Calgary, Canada', 'K3': 'Kowloon Bay, Hong Kong', 'M5': 'Seoul, South Korea', 'W8': 'Istanbul, Turkey', 'R5': 'Lima, Peru', 'K8': 'Jakarta, Indonesia', 'O9': 'Monte Carlo, Monaco',};

        function getCountryForFlag(countryString) {
            const lower = countryString.toLowerCase();
            if (lower.includes('canada')) return 'Canada';
            if (lower.includes('united states') || lower.includes('u.s.') || lower.includes('usa')) return 'United States';
            if (lower.includes('china')) return 'China';
            if (lower.includes('cayman islands')) return 'Cayman Islands';
            if (lower.includes('british virgin islands') || lower.includes('bvi')) return 'British Virgin Islands';
            if (lower.includes('hong kong')) return 'Hong Kong';
            if (lower.includes('israel')) return 'Israel';
            // ... (keep all your existing country checks)
            return countryString;
        }

        class AlertDashboard {
            constructor() {
                this.alerts = new Map(); // ticker -> single most recent alert
                this.updateInterval = 1000; // 1 second
                this.alertThreshold = 0.12; // 12%
                this.volumeThreshold = 1.3; // 1.3x average volume
                this.notifiedAlerts = new Map(); // Track notified alerts to prevent duplicates
                this.recentThreshold = 120000; // 2 minutes in milliseconds
                this.knownAlerts = new Set(); // Track known alerts by unique key (ticker-time)

                // Track next +/- 10% milestone steps from original 12% alert
                // Map key: ticker, value: { upStep: number, downStep: number }
                this.milestones = new Map();

                // Remove loadInitialAlerts() from here - startMonitoring() will handle it
                this.startMonitoring();
            }
            
            async loadInitialAlerts() {
                try {
                    // Clear existing alerts and states
                    this.alerts.clear();
                    this.knownAlerts.clear();
                    
                    // Try local endpoint first (if available), fall back to GitHub raw content
                    let alertData = [];
                    let response;
                    
                    // Determine which URL to use
                    const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                    const alertUrl = isLocalhost ? '/logs/alert.json' : 'https://raw.githubusercontent.com/heyitshurberto/sysd/main/logs/alert.json';
                    
                    try {
                        response = await fetch(alertUrl);
                        if (!response.ok) {
                            console.error('Failed to fetch alert.json:', response.status, response.statusText);
                            // If it's localhost and failed, try GitHub as fallback
                            if (isLocalhost) {
                                response = await fetch('https://raw.githubusercontent.com/heyitshurberto/sysd/main/logs/alert.json');
                            }
                        }
                        
                        if (response.ok) {
                            alertData = await response.json();
                        } else {
                            alertData = [];
                        }
                    } catch (err) {
                        console.error('Error fetching alerts:', err.message);
                        alertData = [];
                    }
                    
                    smartLog('info', `Loaded ${alertData.length} alerts from alert.json`); // Log total count

                    // Load performance/PnL data for reverse split adjustments
                    let performanceData = {};
                    try {
                        const quoteUrl = isLocalhost ? '/logs/quote.json' : 'https://raw.githubusercontent.com/heyitshurberto/sysd/main/logs/quote.json';
                        const pnlResponse = await fetch(quoteUrl);
                        if (pnlResponse.ok) {
                            performanceData = await pnlResponse.json();
                        }
                    } catch (err) {
                        smartLog('warn', `Could not load quote.json for performance data: ${err.message}`);
                    }

                    // Process all alerts in chronological order
                    alertData.sort((a, b) => new Date(b.alertDate) - new Date(a.alertDate));

                    // Initialize monitoring for each alert
                    let loadedCount = 0;
                    let skippedCount = 0;
                    let errorCount = 0;

                    for (const alert of alertData) {
                        try {
                            const price = parseFloat(alert.price);

                            if (!alert.ticker) {
                                smartLog('error', 'Alert missing ticker:', alert);
                                errorCount++;
                                continue;
                            }

                            if (isNaN(price) || price <= 0) {
                                smartLog('error', `Invalid price for ${alert.ticker}: ${alert.price}`);
                                errorCount++;
                                continue;
                            }

                            // Create unique key for this alert
                            const alertKey = `${alert.ticker}-${alert.alertDate}-${alert.price}`;

                            // Skip if already known
                            if (this.knownAlerts.has(alertKey)) {
                                skippedCount++;
                                continue;
                            }

                            // Convert recordedAt to actual Date object if it's a string
                            const alertTime = alert.recordedAt ? new Date(alert.recordedAt) : (alert.alertDate ? new Date(alert.alertDate) : new Date());

                            smartLog('info', `Processing alert for ${alert.ticker} at $${price}`);

                            const sharesOut = parseInt(alert.sharesOutstanding) || 0;
                            const floatShares = parseInt(alert.float) || 0;
                            const mcap = alert.marketCap ? parseFloat(alert.marketCap) : (price * sharesOut);
                            const fiveDay = alert.fiveDChange ? parseFloat(alert.fiveDChange) : 0;

                            // Calculate S/O ratio as percentage (float / shares outstanding)
                            let soRatio = 'N/A';
                            if (floatShares > 0 && sharesOut > 0) {
                              const ratio = (floatShares / sharesOut) * 100;
                              soRatio = ratio < 100 ? ratio.toFixed(2) + '%' : ratio.toFixed(1) + '%';
                            }

                            // Get performance data for this ticker if available
                            const tickerPerfData = performanceData[alert.ticker] || {};
                            
                            this.addAlert({
                                ticker: alert.ticker,
                                title: alert.title,
                                alertPrice: price,
                                currentPrice: tickerPerfData.currentPrice || price, // Use live price from quote.json, fallback to alert price
                                alertTime: alertTime,
                                incorporated: alert.incorporated || 'Unknown',
                                located: alert.located || 'Unknown',
                                signalScore: parseFloat(alert.signalScore) || 5.0,
                                isShort: Array.isArray(alert.isShort) ? alert.isShort.length > 0 : (alert.isShort === true),
                                exchange: alert.exchange || 'NASDAQ',
                                float: parseInt(alert.float) || 0,
                                sharesOutstanding: parseInt(alert.sharesOutstanding) || 0,
                                soRatio: soRatio,
                                ftd: alert.ftd !== undefined ? alert.ftd : false,
                                ftdPercent: alert.ftdPercent || null,
                                filingLink: alert.filingLink || '#',
                                signals: alert.signals || {},
                                bonusSignals: alert.bonusSignals || {},
                                intent: alert.intent || null,
                                currentVolume: parseInt(alert.volume) || 0,
                                volume: parseInt(alert.volume) || 0,
                                averageVolume: parseInt(alert.averageVolume) || 0,
                                marketCap: mcap > 0 ? mcap : null,
                                fiveDChange: !isNaN(fiveDay) ? fiveDay : null,
                                intent: alert.intent || null,
                                bonusSignals: alert.bonusSignals || {},
                                performance: tickerPerfData.performance,
                                reverseSplitRatio: tickerPerfData.reverseSplitRatio || alert.reverseSplitRatio || null, // From quote.json or alert.json
                                reverseSplitReason: alert.reverseSplitReason || null, // From alert.json
                                peakPrice: tickerPerfData.peakPrice || price,
                                lowPrice: tickerPerfData.lowPrice || price,
                                priceChange: (price - price) / price || 0,
                                hasTuesdayBonus: alert.hasTuesdayBonus || false,
                                custodianName: alert.custodianName || null,
                                custodianVerified: alert.custodianVerified || false,
                                filingTimeBonus: alert.filingTimeBonus || null,
                                soBonus: alert.soBonus || null,
                                formType: alert.formType || null,
                                vwap: alert.vwap || null,
                            });

                            // Mark as known
                            this.knownAlerts.add(alertKey);

                            // Initialize milestone tracking for this ticker starting from 12%
                            // Next alerts fire on every additional +/-10% from the original alert price
                            if (!this.milestones.has(alert.ticker)) {
                                this.milestones.set(alert.ticker, { upStep: 0.20, downStep: -0.20 });
                            }
                            loadedCount++;
                        } catch (err) {
                            smartLog('error', `Error processing alert: ${err.message}`);
                            errorCount++;
                        }
                    }

                    smartLog('info', `Alert loading complete: ${loadedCount} loaded, ${errorCount} errors, ${skippedCount} skipped`, true);
                    this.updateDisplay();
                } catch (error) {
                    smartLog('error', 'Failed to load initial alerts: ' + error.message);
                }
            }
            
            handleAlertClick(alert, event) {
                if (event) {
                    event.stopPropagation();
                    event.preventDefault();
                }
                
                // Prevent multiple popups
                const existingPopup = document.querySelector('.alert-popup');
                if (existingPopup) {
                    existingPopup.remove();
                }
                
                // Ensure we have a valid alert object
                if (!alert || typeof alert !== 'object') return;
                
                // Create popup with more detailed information
                const popup = document.createElement('div');
                popup.className = 'alert-popup';
                
                // Convert data for display
                const alertAge = formatAlertAge(alert.alertTime);
                const volumeRatio = alert.averageVolume > 0 ? (alert.currentVolume / alert.averageVolume).toFixed(1) + 'x' : 'N/A';
                const exchange = alert.exchange && alert.exchange !== 'N/A' ? alert.exchange : 'NASDAQ';
                
                // Calculate correct percentage move - USE PEAK for best possible profit
                const isShort = Array.isArray(alert.isShort) ? alert.isShort.length > 0 : (alert.position === 'short' || alert.isShort === true);
                let displayPercentMove = (alert.priceChange * 100).toFixed(2);

                // Prefer adjustedPeakPercent (best possible P&L) when available
                if (alert.performance && typeof alert.performance.adjustedPeakPercent === 'number') {
                    displayPercentMove = alert.performance.adjustedPeakPercent.toFixed(2);
                } else if (alert.performance && typeof alert.performance.adjustedPercent === 'number') {
                    // Fallback to current if peak not available
                    displayPercentMove = alert.performance.adjustedPercent.toFixed(2);
                } else if (alert.reverseSplitRatio && alert.reverseSplitRatio > 1) {
                    // Has reverse split - use/calculate adjusted percentage
                    if (alert.performance && typeof alert.performance.adjustedPeakPercent === 'number') {
                        displayPercentMove = alert.performance.adjustedPeakPercent.toFixed(2);
                    } else if (alert.performance && typeof alert.performance.adjustedPercent === 'number') {
                        displayPercentMove = alert.performance.adjustedPercent.toFixed(2);
                    } else {
                        // Recalculate adjusted peak percent if not available
                        const currentPricePreSplit = alert.currentPrice / alert.reverseSplitRatio;
                        if (isShort) {
                            displayPercentMove = (((alert.alertPrice - currentPricePreSplit) / alert.alertPrice) * 100).toFixed(2);
                        } else {
                            displayPercentMove = (((currentPricePreSplit - alert.alertPrice) / alert.alertPrice) * 100).toFixed(2);
                        }
                    }
                } else if (alert.performance && typeof alert.performance.peakPercent === 'number') {
                    // Use literal peak percent and invert for shorts if needed
                    displayPercentMove = (isShort ? -alert.performance.peakPercent : alert.performance.peakPercent).toFixed(2);
                } else if (isShort) {
                    // No performance data: invert sign for shorts on raw calc
                    displayPercentMove = (parseFloat(displayPercentMove) * -1).toFixed(2);
                }
                
                const priceMove = (alert.currentPrice - alert.alertPrice).toFixed(4);
                
                // Clean title by removing form types (8-K, 6-K, /A)
                let cleanTitle = alert.title || '';
                if (cleanTitle) {
                    cleanTitle = cleanTitle.replace(/^(8-K|6-K|\/A)\s*-?\s*/i, '').trim();
                }
                
                popup.innerHTML = `
                    <div class="popup-content">
                        <h3 style="font-style: italic; padding-left: 4px;">$${alert.ticker}${cleanTitle ? ' ' + cleanTitle : ''} <span style="color: ${isShort ? '#ff0000' : '#00cc00'};">[${isShort ? 'SHORT' : 'LONG'}]</span></h3>
                        <div class="popup-details">
                            <div class="popup-section">
                                <h4>Alert Details</h4>
                                <pre style="margin-top: 4px; padding: 6px; border-radius: 4px; font-size: 10px; line-height: 1.4; font-family: monospace; box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05);"><span style="opacity: 0.7;">Score:</span> ${alert.signalScore.toFixed(1)}
<span style="opacity: 0.7;">Alert:</span> ${alertAge}
<span style="opacity: 0.7;">Date:</span> ${alert.alertTime ? new Date(alert.alertTime).toLocaleDateString() + ' ' + new Date(alert.alertTime).toLocaleTimeString() : 'N/A'}
<span style="opacity: 0.7;">Inc:</span> ${alert.incorporated || 'N/A'}
<span style="opacity: 0.7;">Ops:</span> ${alert.located || 'N/A'}</pre>
                            </div>
                            <div class="popup-section">
                                <h4>Price Action</h4>
                                <pre style="margin-top: 4px; padding: 6px; border-radius: 4px; font-size: 11px; line-height: 1.4; font-family: monospace; box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05);"><span style="opacity: 0.7;">Alert Price:</span> $${alert.alertPrice.toFixed(4)}
<span style="opacity: 0.7;">Current:</span> $${alert.currentPrice.toFixed(4)}
<span style="opacity: 0.7;">Highest:</span> $${(alert.peakPrice || alert.currentPrice).toFixed(4)}
<span style="opacity: 0.7;">Lowest:</span> $${(alert.lowPrice || alert.currentPrice).toFixed(4)}
<span style="opacity: 0.7;">Move:</span> ${displayPercentMove}% ($${priceMove})</pre>
                            </div>
                            <div class="popup-section">
<h4>Company Disclosures</h4>
${alert.signals && typeof alert.signals === 'object' && Object.keys(alert.signals).length > 0 ? 
    `<pre style="margin-top: 4px; padding: 6px; border-radius: 4px; font-size: 11px; line-height: 1.3; font-family: monospace; box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05); word-wrap: break-word; white-space: pre-wrap; overflow-wrap: break-word;">` + 
    Object.entries(alert.signals).map(([signal, reasons]) => 
        `<span style="opacity: 0.7;">${signal}:</span>\n${Array.isArray(reasons) ? reasons.join('\n') : reasons}`
    ).join('\n') + `</pre>`
    : '<pre style="margin-top: 4px; padding: 6px; border-radius: 4px; font-size: 11px; line-height: 1.3; font-family: monospace; box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05); word-wrap: break-word; white-space: pre-wrap; overflow-wrap: break-word;">No signals detected</pre>'}
</div>
<div class="popup-section">
                                <h4>Quote Metrics</h4>
                                <pre style="margin-top: 4px; padding: 6px; border-radius: 4px; font-size: 11px; line-height: 1.4; font-family: monospace; box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05);"><span style="opacity: 0.7;">Market Cap:</span> ${alert.marketCap ? '$' + (alert.marketCap / 1000000).toFixed(2) + 'M' : 'N/A'}
<span style="opacity: 0.7;">Shares:</span> ${alert.sharesOutstanding ? alert.sharesOutstanding.toLocaleString() : 'N/A'}
<span style="opacity: 0.7;">Float:</span> ${alert.float ? alert.float.toLocaleString() : 'N/A'}
<span style="opacity: 0.7;">S/O Ratio:</span> ${alert.soRatio || 'N/A'}${alert.soBonus && alert.soBonus > 1.0 ? ' (' + alert.soBonus.toFixed(2) + 'x)' : ''}
<span style="opacity: 0.7;">VWAP:</span> ${alert.vwap ? '$' + parseFloat(alert.vwap).toFixed(2) + (alert.currentPrice && alert.vwap ? ` (Spread: ${((alert.currentPrice - alert.vwap) / alert.vwap * 100).toFixed(2)}%)` : '') : 'N/A'}
<span style="opacity: 0.7;">FTD:</span> ${alert.ftd !== false && alert.ftd !== null && alert.ftd !== undefined && alert.ftd !== 'False' ? (typeof alert.ftd === 'number' ? alert.ftd.toLocaleString() : alert.ftd) + (alert.ftdPercent ? ' (' + alert.ftdPercent + '%)' : '') : 'False'}${alert.custodianName ? '\n<span style="opacity: 0.7;">Banks:</span> ' + alert.custodianName : ''}
<span style="opacity: 0.7;">Bonus:</span> ${alert.hasTuesdayBonus ? 'Tuesday Window' : 'None'}${alert.bonusSignals && typeof alert.bonusSignals === 'object' ? Object.entries(alert.bonusSignals).map(([bonus, value]) => {
        if (bonus === 'DTC Chill Lift' && value) return '\nDTC Chill Lift';
        if (bonus === 'Shell Recycling' && value) return '\nShell Recycling';
        if (bonus === 'VStock' && value) return '\nVStock Setup';
        if (bonus === 'NT 10K' && value === 'NT 10K Filed') return '\nNT 10-K Filed';
        if (bonus === 'NT 10K' && value === 'Actual 10K Filed') return '\nActual 10-K';
        if (bonus === 'Third Party' && Array.isArray(value) && value.length > 0) return '\nServices: ' + value.join(', ');
        return '';
    }).filter(x => x).join('') : ''}${alert.reverseSplitRatio ? '\n<span style="opacity: 0.7;">Stock Split:</span> 1-for-' + alert.reverseSplitRatio : ''}</pre>
                            </div>
                        </div>
                        <div class="popup-footer">
                            <button onclick="(() => {
                                const ticker = '${alert.ticker}';
                                const exchange = '${alert.exchange || 'NASDAQ'}';
                                console.log('Popup TradingView button clicked:', { ticker, exchange });
                                const tvSymbol = getTradingViewSymbol(ticker, exchange);
                                console.log('Generated tvSymbol:', tvSymbol);
                                const url = \`https://www.tradingview.com/chart/?symbol=\${tvSymbol}\`;
                                console.log('Opening URL:', url);
                                customConfirm(\`Open TradingView chart for $${ticker}?\`, url);
                            })()">TradingView</button>
                            <button onclick="(() => {
                                customConfirm(\`View Financials for $${alert.ticker}?\`, \`https://stockanalysis.com/stocks/${alert.ticker}/statistics/\`);
                            })()">Financials</button>
                            <button onclick="(() => {
                                customConfirm(\`Open Trading 212 to trade $${alert.ticker}?\`, 'https://www.trading212.com/en/login');
                            })()">Trading 212</button>
                           <button onclick="this.closest('.alert-popup').remove()">Close</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(popup);
                
                // Add popup close functionality
                popup.addEventListener('click', (e) => {
                    if (e.target === popup) {
                        popup.remove();
                    }
                });
            }

            addAlert(alertData) {
                // Create unique key for this alert based on ticker and time
                const alertKey = `${alertData.ticker}-${alertData.alertTime}`;
                
                // Skip if we've already processed this alert
                if (this.knownAlerts.has(alertKey)) {
                    return;
                }
                
                const isShort = Array.isArray(alertData.isShort) ? alertData.isShort.length > 0 : alertData.isShort;
                
                // Determine initial peak/low based on server-provided values
                const parsedAlertTime = alertData.alertTime ? new Date(alertData.alertTime) : new Date();
                let initialPeak = alertData.alertPrice;
                let initialLow = alertData.alertPrice;

                if (alertData.peakPrice !== undefined) {
                    initialPeak = parseFloat(alertData.peakPrice);
                }
                if (alertData.lowPrice !== undefined) {
                    initialLow = parseFloat(alertData.lowPrice);
                }

                const alert = {
                    ...alertData,
                    currentPrice: alertData.alertPrice,
                    peakPrice: initialPeak,
                    lowPrice: initialLow,
                    currentVolume: 0,
                    averageVolume: 0,
                    priceChange: 0,
                    volumeSpike: false,
                    triggered: false,
                    lastUpdated: new Date(),
                    lastTriggerLevel: 0,
                    initialValue: isShort ? -alertData.alertPrice : alertData.alertPrice
                };

                // Only store one alert per ticker - replace if exists
                this.alerts.set(alertData.ticker, [alert]);
                
                // Mark this alert as known
                this.knownAlerts.add(alertKey);

                if (alertData.signalScore > 0.0) {
                    const alertKey = `${alertData.ticker}-${alertData.alertTime.getTime()}`;
                    const now = Date.now();
                    const isRecent = this.notifiedAlerts.has(alertKey) && (now - this.notifiedAlerts.get(alertKey)) < this.recentThreshold;

                    if (!isRecent) {
                        const position = alertData.isShort ? 'SHORT' : 'LONG';
                        const type = alertData.isShort ? 'error' : 'success';
                        const ticker = `<b><i>$${alertData.ticker}</i></b>`;
                        // For new stock alerts, link to SEC filing
                        this.showNotification(`${ticker} ${position} alert (Score: ${alertData.signalScore.toFixed(1)})`, type, alertData.filingLink);
                        this.notifiedAlerts.set(alertKey, now);
                    }
                }

                this.updateDisplay();
            }
            
            async startMonitoring() {
                // Wait for initial alerts to load first
                await this.loadInitialAlerts();

                // Create a persistent store for dropdown states
                if (!window.dropdownStates) {
                    window.dropdownStates = new Map();
                    // Load saved states from localStorage
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key.startsWith('dropdown_')) {
                            const ticker = key.replace('dropdown_', '');
                            window.dropdownStates.set(ticker, { isOpen: true });
                        }
                    }
                }

                // Check for new tickers in alert.json every 2 seconds
                setInterval(() => {
                    this.checkForNewAlerts();
                }, 2000); // Check for new alerts every 2 seconds

                // Then start the monitoring interval for price updates
                setInterval(() => {
                    this.checkAllPrices();
                }, 2000); // Check prices every 2 seconds

                // Initial checks
                this.checkForNewAlerts();
                this.checkAllPrices();
            }
            
            updatePriceDisplay(alert, card) {
                if (!card) return;
                
                // Save dropdown state before updates
                const dropdown = card.querySelector('.score-breakdown');
                const dropdownButton = card.querySelector('.score-details-toggle');
                const wasOpen = dropdown && (dropdown.style.display === 'block' || window.dropdownStates?.get(alert.ticker)?.isOpen);
                
                // Update price elements
                const currentPriceEl = card.querySelector('div:nth-child(6)');
                const priceChangeEl = card.querySelector('.price-change');
                if (currentPriceEl && priceChangeEl) {
                    currentPriceEl.textContent = `Current: $${alert.currentPrice.toFixed(4)}`;
                    
                    // Calculate correct percentage change - USE PEAK for best possible profit
                    const isShort = Array.isArray(alert.isShort) ? alert.isShort.length > 0 : (alert.position === 'short' || alert.isShort === true);
                    let displayPercent = (alert.priceChange * 100).toFixed(2);

                    // Prefer adjustedPeakPercent (best possible P&L) when available
                    if (alert.performance && typeof alert.performance.adjustedPeakPercent === 'number') {
                        displayPercent = alert.performance.adjustedPeakPercent.toFixed(2);
                    } else if (alert.performance && typeof alert.performance.adjustedPercent === 'number') {
                        displayPercent = alert.performance.adjustedPercent.toFixed(2);
                    } else if (alert.performance && typeof alert.performance.peakPercent === 'number') {
                        displayPercent = (isShort ? -alert.performance.peakPercent : alert.performance.peakPercent).toFixed(2);
                    } else if (alert.performance && typeof alert.performance.percent === 'number') {
                        displayPercent = (isShort ? -alert.performance.percent : alert.performance.percent).toFixed(2);
                    } else if (alert.reverseSplitRatio && alert.reverseSplitRatio > 1) {
                        // Has reverse split - calculate peak adjusted percent
                        const currentPricePreSplit = alert.currentPrice / alert.reverseSplitRatio;
                        if (isShort) {
                            displayPercent = (((alert.alertPrice - currentPricePreSplit) / alert.alertPrice) * 100).toFixed(2);
                        } else {
                            displayPercent = (((currentPricePreSplit - alert.alertPrice) / alert.alertPrice) * 100).toFixed(2);
                        }
                    } else if (isShort) {
                        // SHORT without reverse split: invert the sign
                        displayPercent = (parseFloat(displayPercent) * -1).toFixed(2);
                    }
                    
                    priceChangeEl.textContent = `${displayPercent}% ($${(alert.currentPrice - alert.alertPrice).toFixed(4)})`;
                    
                    // Determine color based on win/loss
                    let isWin;
                    if (isShort) {
                        isWin = parseFloat(displayPercent) > 0;
                    } else {
                        isWin = parseFloat(displayPercent) > 0;
                    }
                    priceChangeEl.className = `price-change ${isWin ? 'positive' : (parseFloat(displayPercent) === 0 ? 'neutral' : 'negative')}`;
                }

                // Update timestamp
                const timestampEl = card.querySelector('.timestamp');
                if (timestampEl) {
                    const usTimeStr = alert.lastUpdated.toLocaleTimeString('en-US', {
                        timeZone: 'America/New_York',
                        hour12: false,
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                    timestampEl.textContent = `Updated: ${usTimeStr} ET`;
                }
                
                // Restore dropdown state
                if (wasOpen && dropdown && dropdownButton) {
                    dropdown.style.display = 'block';
                    dropdown.style.opacity = '1';
                    dropdown.style.transform = 'translateY(0)';
                    dropdown.style.pointerEvents = 'auto';
                    dropdownButton.textContent = '▲';
                    card.dataset.dropdownOpen = 'true';
                    
                    // Ensure state is preserved in window storage
                    if (!window.dropdownStates) window.dropdownStates = new Map();
                    window.dropdownStates.set(alert.ticker, {
                        isOpen: true,
                        timestamp: Date.now()
                    });
                }
            }

            async checkAllPrices() {
                this.updateLastUpdate();
                const tickers = Array.from(this.alerts.keys());

                let updatedPrices = false;
                for (const ticker of tickers) {
                    const priceUpdated = await this.checkStockPrice(ticker);
                    if (priceUpdated) {
                        updatedPrices = true;
                        // Update just this ticker's card
                        const alert = this.alerts.get(ticker);
                        const card = document.querySelector(`[data-ticker="${ticker}"]`);
                        this.updatePriceDisplay(alert, card);
                    }
                    // Increased delay between ticker checks to 1.5 seconds
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }

                // Update P/L stats without full refresh
                if (updatedPrices) {
                    const plStats = this.calculateProfitLoss();
                    const plCount = document.getElementById('pl-count');
                    if (plCount) {
                        plCount.innerHTML = `${totalSign}${plStats.total}% <span style="font-size: 11.5px;">(L:${plStats.longCount}/${longSign}${plStats.longStr}% | S:${plStats.shortCount}/${shortSign}${plStats.shortStr}%)</span>`;
                        plCount.style.color = plStats.total > 0 ?
                            (document.body.classList.contains('dark-mode') ? '#1fff1f' : '#00aa00') :
                            plStats.total < 0 ?
                            (document.body.classList.contains('dark-mode') ? '#ff3333' : '#aa0000') : '#666';
                    }
                }
            }

            async checkForNewAlerts() {
                try {
                    // Determine which URL to use
                    const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                    const alertUrl = isLocalhost ? '/logs/alert.json' : 'https://raw.githubusercontent.com/heyitshurberto/sysd/main/logs/alert.json';
                    
                    let response;
                    try {
                        response = await fetch(alertUrl);
                        if (!response.ok && isLocalhost) {
                            // Fall back to GitHub if localhost fails
                            response = await fetch('https://raw.githubusercontent.com/heyitshurberto/sysd/main/logs/alert.json');
                        }
                    } catch (err) {
                        console.error('Error fetching new alerts:', err.message);
                        return;
                    }
                    
                    if (!response.ok) {
                        console.error('Failed to fetch alert.json for updates:', response.status, response.statusText);
                        return;
                    }
                    const alertData = await response.json();

                    // Get only the most recent 50 alerts
                    const recentAlerts = alertData.slice(-50);
                    
                    const newAlertCards = [];

                    // Process new alerts without clearing existing ones
                    for (const alert of recentAlerts) {
                        const alertKey = `${alert.ticker}-${alert.alertDate}-${alert.price}`;
                        
                        // Only add if we haven't seen this specific alert before
                        if (!this.knownAlerts.has(alertKey)) {
                            this.knownAlerts.add(alertKey);
                            
                            // Create new alert object
                            const newAlert = {
                                ...alert,
                                currentPrice: alert.price,
                                alertPrice: parseFloat(alert.price),
                                alertTime: alert.recordedAt ? new Date(alert.recordedAt) : new Date(),
                                // Initialize peak and low to alert price - the baseline for tracking
                                peakPrice: parseFloat(alert.price),
                                lowPrice: parseFloat(alert.price),
                                priceChange: 0,
                                volumeSpike: false,
                                triggered: false
                            };

                            // Add to alerts map (keyed by ticker)
                            if (!this.alerts.has(alert.ticker)) {
                                this.alerts.set(alert.ticker, []);
                            }
                            this.alerts.get(alert.ticker).push(newAlert);
                            
                            // Create card element (don't insert yet)
                            const alertCard = this.createAlertCard(newAlert);
                            newAlertCards.push(alertCard);
                            
                            // Show notification for all alerts
                            if (parseFloat(alert.signalScore) > 0.01) {
                                const position = Array.isArray(alert.isShort) ? (alert.isShort.length > 0 ? 'SHORT' : 'LONG') : (alert.isShort ? 'SHORT' : 'LONG');
                                const type = alert.isShort ? 'error' : 'success';
                                const ticker = `<b>$${alert.ticker}</b>`;
                                this.showNotification(`${ticker} ${position} (Score: ${parseFloat(alert.signalScore).toFixed(1)})`, type, alert.filingLink || '#');
                            }
                            
                            // Log new ticker
                            smartLog('info', `New ticker found in alert.json: ${alert.ticker} @ $${alert.price}`);
                        }
                    }

                    // Only update display if new alerts were found
                    if (newAlertCards.length > 0) {
                        this.addNewAlertCards(newAlertCards);
                    }
                    
                } catch (error) {
                    console.error('Failed to check for new alerts:', error);
                }
            }

            addNewAlertCards(newCards) {
                const container = document.getElementById('alerts-container');
                if (!container) return;
                
                // Insert new cards at the top (before existing cards)
                newCards.forEach(card => {
                    container.insertBefore(card, container.firstChild);
                });
                
                // Update the active count
                const activeCount = document.getElementById('active-count');
                if (activeCount) {
                    const count = container.querySelectorAll('.alert-card').length;
                    activeCount.textContent = count;
                }
                
                // Update P/L stats
                const plStats = this.calculateProfitLoss();
                const plCount = document.getElementById('pl-count');
                if (plCount) {
                    const totalSign = parseFloat(plStats.total) > 0 ? '+' : '';
                    const longSign = parseFloat(plStats.longStr) > 0 ? '+' : '';
                    const shortSign = parseFloat(plStats.shortStr) > 0 ? '+' : '';
                    plCount.innerHTML = `${totalSign}${plStats.total}% <span style="font-size: 11.5px;">(L:${plStats.longCount}/${longSign}${plStats.longStr}% | S:${plStats.shortCount}/${shortSign}${plStats.shortStr}%)</span>`;
                    plCount.style.color = parseFloat(plStats.total) > 0 ? 
                        (document.body.classList.contains('dark-mode') ? '#1fff1f' : '#00aa00') : 
                        parseFloat(plStats.total) < 0 ? 
                        (document.body.classList.contains('dark-mode') ? '#ff3333' : '#aa0000') : 
                        '#666';
                }
            }

            async checkStockPrice(ticker) {
                try {
                    // Check if viewing from localhost (has local API server)
                    const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                    
                    let quote;
                    
                    if (isLocalhost) {
                        // Use local API endpoint for real-time prices
                        const response = await fetch(`/api/quote/${ticker}`);
                        if (!response.ok) {
                            console.error(`Failed to fetch quote for ${ticker}: ${response.status}`);
                            return false;
                        }
                        
                        try {
                            quote = await response.json();
                        } catch (parseError) {
                            console.error(`Failed to parse JSON for ${ticker}:`, parseError);
                            return false;
                        }
                    } else {
                        // On GitHub Pages - fetch from quote.json which is updated by the bot
                        try {
                            const quoteUrl = 'https://raw.githubusercontent.com/heyitshurberto/sysd/main/logs/quote.json';
                            const response = await fetch(quoteUrl);
                            if (response.ok) {
                                const quoteData = await response.json();
                                if (quoteData[ticker] && quoteData[ticker].currentPrice) {
                                    // Create a quote object matching the API format
                                    quote = {
                                        price: quoteData[ticker].currentPrice,
                                        volume: quoteData[ticker].volume || 0,
                                        averageVolume: quoteData[ticker].averageVolume || 0,
                                        marketCap: quoteData[ticker].marketCap || 'N/A'
                                    };
                                } else {
                                    console.warn(`No price data for ${ticker} in quote.json`);
                                    return false;
                                }
                            } else {
                                console.error(`Failed to fetch quote.json: ${response.status}`);
                                return false;
                            }
                        } catch (err) {
                            console.error(`Error fetching quote.json for ${ticker}:`, err);
                            return false;
                        }
                    }

                    if (!quote || typeof quote.price === 'undefined' || quote.price <= 0) {
                        console.error(`Invalid quote data for ${ticker}:`, quote);
                        return false;
                    }

                    const alerts = this.alerts.get(ticker);
                    if (!alerts || !alerts.length) {
                        console.log(`No alerts found for ${ticker}`);
                        return false;
                    }

                    // Update network status to Online on successful API call
                    const statusEl = document.getElementById('status');
                    statusEl.className = 'status-online';

                    const currentPrice = parseFloat(quote.price);
                    const currentVolume = parseInt(quote.volume) || 0;
                    const averageVolume = parseInt(quote.averageVolume) || 0;

                    let priceChanged = false;
                    for (const alert of alerts) {
                        // Calculate price change from alert price
                        const priceChange = (currentPrice - alert.alertPrice) / alert.alertPrice;
                        const volumeSpike = averageVolume > 0 ? currentVolume / averageVolume >= this.volumeThreshold : false;

                        // Only count as changed if price is different
                        if (currentPrice !== alert.currentPrice) {
                            priceChanged = true;
                        }

                        // Update alert
                        alert.currentPrice = currentPrice;
                        
                        // Always fetch updated performance data for reverse split adjustments
                        try {
                            const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                            const quoteUrl = isLocalhost ? '/logs/quote.json' : 'https://raw.githubusercontent.com/heyitshurberto/sysd/main/logs/quote.json';
                            const pnlResp = await fetch(quoteUrl);
                            if (pnlResp.ok) {
                                const pnlData = await pnlResp.json();
                                const tickerPerf = pnlData[alert.ticker];
                                if (tickerPerf) {
                                    // Only update reverse split and performance data, NOT price (use live API price)
                                    if (tickerPerf.reverseSplitRatio) {
                                        alert.reverseSplitRatio = tickerPerf.reverseSplitRatio;  // Lock in reverse split ratio
                                    }
                                    if (tickerPerf.performance && tickerPerf.performance.adjustedPercent !== undefined) {
                                        // Attach both legacy property and performance object field
                                        alert.adjustedPercent = tickerPerf.performance.adjustedPercent;
                                        if (!alert.performance) alert.performance = {};
                                        alert.performance.adjustedPercent = tickerPerf.performance.adjustedPercent;
                                    }
                                }
                            }
                        } catch (err) {
                            // Silently fail - use calculated value
                        }
                        
                        // For LONG positions: peak = highest price (max profit), low = lowest price
                        // For SHORT positions: peak = lowest price (max profit), low = highest price
                        const isShortForPeakTracking = Array.isArray(alert.isShort) ? alert.isShort.length > 0 : (alert.isShort === true);
                        if (isShortForPeakTracking) {
                            // SHORT: profit when price GOES DOWN
                            alert.peakPrice = Math.min(alert.peakPrice, currentPrice);
                            alert.lowPrice = Math.max(alert.lowPrice, currentPrice);
                        } else {
                            // LONG: profit when price GOES UP
                            alert.peakPrice = Math.max(alert.peakPrice, currentPrice);
                            alert.lowPrice = Math.min(alert.lowPrice, currentPrice);
                        }
                        
                        alert.currentVolume = currentVolume;
                        alert.averageVolume = averageVolume;
                        alert.priceChange = priceChange;
                        alert.volumeSpike = volumeSpike;
                        alert.lastUpdated = new Date();

                        // Check for 12% initial trigger
                        if (Math.abs(priceChange) >= this.alertThreshold && !alert.triggered) {
                            alert.triggered = true;
                            this.triggerAlert(alert);
                            // On first trigger, ensure milestones exist
                            if (!this.milestones.has(alert.ticker)) {
                                this.milestones.set(alert.ticker, { upStep: 0.20, downStep: -0.20 });
                            }
                            // Initialize milestone tracking
                            if (!alert.notifiedMilestones) {
                                alert.notifiedMilestones = new Set();
                                alert.milestoneEvents = [];
                            }
                        }

                        // After initial trigger, check and notify on milestone crossings
                        const ms = this.milestones.get(alert.ticker);
                        if (ms && alert.triggered) {
                            // Initialize if needed
                            if (!alert.notifiedMilestones) {
                                alert.notifiedMilestones = new Set();
                                alert.milestoneEvents = [];
                            }
                            
                            // Upwards milestones - notify when crossed
                            while (priceChange >= ms.upStep) {
                                const milestonePercent = Math.round(ms.upStep * 100);
                                if (!alert.notifiedMilestones.has(milestonePercent)) {
                                    alert.notifiedMilestones.add(milestonePercent);
                                    
                                    // Create milestone event
                                    const direction = priceChange > 0 ? 'up' : 'down';
                                    const milestoneEvent = {
                                        percent: milestonePercent,
                                        direction: direction,
                                        timestamp: new Date(),
                                        price: currentPrice
                                    };
                                    alert.milestoneEvents.push(milestoneEvent);
                                    
                                    // Send notification
                                    const notificationMsg = `<b>$${alert.ticker}</b> ${direction} <b>${milestonePercent}%</b> from alert price`;
                                    this.showNotification(notificationMsg, 'success', alert.filingLink);
                                    
                                    // Send to Raspberry Pi
                                    this.sendToRaspberryPi({
                                        ...alert,
                                        priceChange: ms.upStep,
                                        isMilestone: true,
                                        milestonePercent: milestonePercent
                                    });
                                }
                                // Increment: 25% up to 100%, then 50% increments
                                if (ms.upStep < 1.0) {
                                    ms.upStep += 0.25;  // 25% increments
                                } else {
                                    ms.upStep += 0.50;  // 50% increments above 100%
                                }
                            }
                            
                            // Downwards milestones - notify when crossed
                            while (priceChange <= ms.downStep) {
                                const milestonePercent = Math.round(Math.abs(ms.downStep) * 100);
                                if (!alert.notifiedMilestones.has(-milestonePercent)) {
                                    alert.notifiedMilestones.add(-milestonePercent);
                                    
                                    // Create milestone event
                                    const direction = 'down';
                                    const milestoneEvent = {
                                        percent: -milestonePercent,
                                        direction: direction,
                                        timestamp: new Date(),
                                        price: currentPrice
                                    };
                                    alert.milestoneEvents.push(milestoneEvent);
                                    
                                    // Send notification
                                    const notificationMsg = `<b>$${alert.ticker}</b> ${direction} <b>${milestonePercent}%</b> from alert`;
                                    this.showNotification(notificationMsg, 'error', alert.filingLink);
                                    
                                    // Send to Raspberry Pi
                                    this.sendToRaspberryPi({
                                        ...alert,
                                        priceChange: ms.downStep,
                                        isMilestone: true,
                                        milestonePercent: milestonePercent
                                    });
                                }
                                // Decrement: 25% down to -100%, then 50% increments
                                if (ms.downStep > -1.0) {
                                    ms.downStep -= 0.25;  // 25% increments
                                } else {
                                    ms.downStep -= 0.50;  // 50% increments below -100%
                                }
                            }
                            
                            // Persist updated steps
                            this.milestones.set(alert.ticker, ms);
                        }
                    }

                    // Force stats update after each price check
                    this.updateDisplay();
                    return priceChanged;

                } catch (error) {
                    smartLog('error', `Failed to check ${ticker}: ${error.message}`);
                }
            }

            
            triggerAlert(alert) {
                // Visual and audio alert
                playTieredAlert(alert.priceChange);

                // Log to console
                const direction = alert.priceChange > 0 ? 'UP' : 'DOWN';
                const percent = (Math.abs(alert.priceChange) * 100).toFixed(1);
                smartLog('info', `% ${alert.ticker} ${direction} ${percent}% | Alert: $${alert.alertPrice.toFixed(4)} → Now: $${alert.currentPrice.toFixed(4)}`, true); // Force price alerts

                // Send to Raspberry Pi speaker endpoint
                this.sendToRaspberryPi(alert);

                // Could also send to Discord here
                this.sendDiscordAlert(alert);
            }
            

            
            async sendToRaspberryPi(alert) {
                try {
                    const direction = alert.priceChange > 0 ? 'UP' : 'DOWN';
                    const percent = (Math.abs(alert.priceChange) * 100).toFixed(1);

                    await fetch('http://raspberrypi.local:8080/alert', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            ticker: alert.ticker,
                            direction: direction,
                            percent: percent,
                            alertPrice: alert.alertPrice,
                            currentPrice: alert.currentPrice,
                            timestamp: new Date().toISOString()
                        })
                    });
                } catch (error) {
                    console.log('Failed to send alert to Raspberry Pi:', error);
                }
            }

            async sendDiscordAlert(alert) {
                // You can implement Discord webhook here
                // Similar to your existing Discord alert logic
            }
            
            calculateProfitLoss() {
                let longCount = 0, longPL = 0;
                let shortCount = 0, shortPL = 0;

                this.alerts.forEach(alerts => {
                    // Ensure we're working with an array
                    const alertArray = Array.isArray(alerts) ? alerts : [alerts];
                    
                    alertArray.forEach(alert => {
                        if (!alert || !alert.currentPrice || !alert.alertPrice) return;
                        
                        // Detect if short: check isShort field (can be boolean, array, or undefined) or position field
                        const isShort = (Array.isArray(alert.isShort) ? alert.isShort.length > 0 : (alert.isShort === true)) || alert.position === 'short';
                        
                        // Always calculate from live currentPrice and alertPrice (don't use stale performance data)
                        let priceChangePercent = ((alert.currentPrice - alert.alertPrice) / alert.alertPrice) * 100;
                        
                        // Check for reverse split ratio
                        let reverseSplitRatio = alert.reverseSplitRatio;
                        if (!reverseSplitRatio && (isShort || (priceChangePercent > 1000))) {
                            // Auto-detect from price ratio for HUGE moves
                            const priceRatio = alert.currentPrice / alert.alertPrice;
                            if (priceRatio > 2.5 && priceRatio < 10) reverseSplitRatio = 100;
                            else if (priceRatio >= 10 && priceRatio < 20) reverseSplitRatio = 50;
                            else if (priceRatio >= 20 && priceRatio < 30) reverseSplitRatio = 20;
                            else if (priceRatio >= 30 && priceRatio < 50) reverseSplitRatio = 10;
                            else if (priceRatio >= 50 && priceRatio < 100) reverseSplitRatio = 5;
                        }
                        
                        // Apply reverse split adjustment
                        let returnPercent;
                        if (reverseSplitRatio && reverseSplitRatio > 1) {
                            // For BOTH LONG and SHORT with reverse splits
                            const adjustedEntry = alert.alertPrice * reverseSplitRatio;
                            if (isShort) {
                                returnPercent = ((adjustedEntry - alert.currentPrice) / adjustedEntry) * 100;
                            } else {
                                // LONG: adjust current price back to pre-split basis for accurate calculation
                                const adjustedCurrent = alert.currentPrice * reverseSplitRatio;
                                returnPercent = ((adjustedCurrent - adjustedEntry) / adjustedEntry) * 100;
                            }
                        } else {
                            // For P&L: LONG profits when price goes UP (positive), SHORTS profit when price goes DOWN (negative price change = positive P&L)
                            returnPercent = isShort ? -priceChangePercent : priceChangePercent;
                        }
                        
                        if (isNaN(returnPercent)) return;
                        
                        if (isShort) {
                            shortCount++;
                            shortPL += returnPercent;
                        } else {
                            longCount++;
                            longPL += returnPercent;
                        }
                    });
                });

                // Calculate averages by position type
                const longAvg = longCount > 0 ? longPL / longCount : 0;
                const shortAvg = shortCount > 0 ? shortPL / shortCount : 0;
                
                // Total P&L is the unweighted average of ALL trades (equal weight per position, not per dollar)
                const totalCount = longCount + shortCount;
                const totalPL = totalCount > 0 ? (longPL + shortPL) / totalCount : 0;
                const totalPLStr = totalPL.toFixed(2);

                // Return averages for display
                const longPLStr = longAvg.toFixed(2);
                const shortPLStr = shortAvg.toFixed(2);

                return {
                    total: totalPLStr,
                    longStr: longPLStr,
                    shortStr: shortPLStr,
                    longCount,
                    shortCount
                };
            }
            
            updateDisplay() {
                const container = document.getElementById('alerts-container');
                const activeCount = document.getElementById('active-count');
                const plCount = document.getElementById('pl-count');
                
                // Calculate P/L stats
                const plStats = this.calculateProfitLoss();
                const totalSign = parseFloat(plStats.total) > 0 ? '+' : '';
                const longSign = parseFloat(plStats.longStr) > 0 ? '+' : '';
                const shortSign = parseFloat(plStats.shortStr) > 0 ? '+' : '';
                
                plCount.innerHTML = `${totalSign}${plStats.total}% <span style="font-size: 11.5px;">(L:${plStats.longCount}/${longSign}${plStats.longStr}% | S:${plStats.shortCount}/${shortSign}${plStats.shortStr}%)</span>`;
                plCount.style.color = parseFloat(plStats.total) > 0 ? 
                    (document.body.classList.contains('dark-mode') ? '#1fff1f' : '#00aa00') : 
                    parseFloat(plStats.total) < 0 ? 
                    (document.body.classList.contains('dark-mode') ? '#ff3333' : '#aa0000') : 
                    '#666';
                
                // Store currently open dropdowns before update
                const openDropdownStates = new Map();
                document.querySelectorAll('.alert-card').forEach(card => {
                    const ticker = card.querySelector('.ticker').textContent.split(' ')[0].replace('$', '');
                    const dropdown = card.querySelector('.score-breakdown');
                    if (dropdown && dropdown.style.display === 'block') {
                        openDropdownStates.set(ticker, true);
                    }
                });
                
                // Store current dropdown states and positions before updating
                const openDropdowns = new Map();
                document.querySelectorAll('.score-breakdown').forEach(dropdown => {
                    if (dropdown.style.display === 'block') {
                        const alertCard = dropdown.closest('.alert-card');
                        const ticker = alertCard.querySelector('.ticker').textContent.split(' ')[0].replace('$', '');
                        const button = alertCard.querySelector('.score-details-toggle');
                        openDropdowns.set(ticker, {
                            isOpen: true,
                            opacity: dropdown.style.opacity,
                            transform: dropdown.style.transform,
                            pointerEvents: dropdown.style.pointerEvents,
                            buttonText: button ? button.textContent : '▲'
                        });
                    }
                });

                // Capture current scroll position and save it
                const scrollPos = container.scrollTop;
                
                // Store all open dropdowns before clearing
                const openStates = new Map();
                
                // Save the scroll position to restore it later
                const shouldRestoreScroll = scrollPos > 0;
                document.querySelectorAll('.alert-card').forEach(card => {
                    const ticker = card.querySelector('.ticker').textContent.split(' ')[0].replace('$', '');
                    const dropdown = card.querySelector('.score-breakdown');
                    if (dropdown && (dropdown.style.display === 'block' || card.dataset.dropdownOpen === 'true')) {
                        openStates.set(ticker, true);
                    }
                });

                // Clear container
                container.innerHTML = '';
                
                // We'll restore scroll position after updating

                // Sort alerts by most recent price movement
                const sortedAlerts = Array.from(this.alerts.values())
                    .flat()
                    .sort((a, b) => Math.abs(b.priceChange) - Math.abs(a.priceChange));

                // Calculate total P/L, considering position type
                let totalPL = 0;
                let totalLongPL = 0;
                let totalShortPL = 0;
                
                sortedAlerts.forEach(alert => {
                    const pl = alert.priceChange * 100;
                    if (isShortSetup(alert)) {
                        totalShortPL += -pl; // Negative because profit is inverse of price change for shorts
                        totalPL += -pl;
                    } else {
                        totalLongPL += pl;
                        totalPL += pl;
                    }
                });

                // Get alert counts by type
                const longCount = sortedAlerts.filter(alert => !isShortSetup(alert)).length;
                const shortCount = sortedAlerts.filter(alert => isShortSetup(alert)).length;

                let triggered = 0;

                // Rebuild alerts and restore dropdown states
                sortedAlerts.forEach(alert => {
                    if (alert.triggered) triggered++;

                    const alertCard = this.createAlertCard(alert);
                    container.appendChild(alertCard);

                    // Restore dropdown state if it was open
                    const wasOpen = openDropdownStates.has(alert.ticker) || localStorage.getItem(`dropdown_${alert.ticker}`) === 'open';
                    if (wasOpen) {
                        const dropdown = alertCard.querySelector('.score-breakdown');
                        const button = alertCard.querySelector('.score-details-toggle');
                        if (dropdown && button) {
                            dropdown.style.display = 'block';
                            dropdown.style.opacity = '1';
                            dropdown.style.transform = 'translateY(0)';
                            dropdown.style.pointerEvents = 'auto';
                            button.textContent = '▲';
                            alertCard.dataset.dropdownOpen = 'true';
                            // Update global tracking
                            window.activeDropdown = dropdown;
                            window.lastActiveTicker = alert.ticker;
                        }
                    }
                    if (openDropdowns.has(alert.ticker) || localStorage.getItem(`dropdown_${alert.ticker}`) === 'open') {
                        const dropdown = alertCard.querySelector('.score-breakdown');
                        const button = alertCard.querySelector('.score-details-toggle');
                        if (dropdown && button) {
                            dropdown.style.display = 'block';
                            dropdown.style.opacity = '1';
                            dropdown.style.transform = 'translateY(0)';
                            dropdown.style.pointerEvents = 'auto';
                            button.textContent = '▲';
                            if (alert.ticker === lastActiveTicker) {
                                activeDropdown = dropdown;
                            }
                            alertCard.dataset.dropdownOpen = 'true';
                            
                            // Create a single MutationObserver per dropdown
                            if (!dropdown._observer) {
                                dropdown._observer = new MutationObserver((mutations) => {
                                    // Only update if the dropdown should be open
                                    if (alertCard.dataset.dropdownOpen === 'true') {
                                        requestAnimationFrame(() => {
                                            dropdown.style.display = 'block';
                                            dropdown.style.opacity = '1';
                                            dropdown.style.transform = 'translateY(0)';
                                            dropdown.style.pointerEvents = 'auto';
                                            button.textContent = '▲';
                                        });
                                    }
                                });
                                
                                // Observe both style and class changes
                                dropdown._observer.observe(dropdown, {
                                    attributes: true,
                                    attributeFilter: ['style', 'class']
                                });
                                
                                // Cleanup observer when dropdown is removed
                                new MutationObserver((mutations) => {
                                    if (!document.contains(dropdown)) {
                                        dropdown._observer.disconnect();
                                        delete dropdown._observer;
                                    }
                                }).observe(document.body, {
                                    childList: true,
                                    subtree: true
                                });
                            }
                        }
                    }
                });

                activeCount.innerHTML = `${sortedAlerts.length} <span style="font-size: 11.5px;">(L:${longCount} | S:${shortCount})</span>`;
            

                // Restore scroll position after update if needed
                if (shouldRestoreScroll) {
                    requestAnimationFrame(() => {
                        container.scrollTop = scrollPos;
                    });
                }
            }
            
            createAlertCard(alert) {
                const card = document.createElement('div');
                const isShort = alert.isShort === true || alert.short === true;
                
                // Determine price movement class - use priceChange (already calculated correctly for all cases)
                let effectivePriceChange = alert.priceChange;
                if (isShort) {
                    // For shorts: priceChange is (current - alert) / alert
                    // Negative change = price down = profit for short, so invert the sign
                    effectivePriceChange = -alert.priceChange;
                }
                // For reverse splits: alert.priceChange already reflects actual P&L since alertPrice and currentPrice
                // are both in their respective market units. No adjustment needed.
                
                // Determine price movement class
                const directionClass = effectivePriceChange > 0 ? 'up' : effectivePriceChange < 0 ? 'down' : 'neutral';
                
                // Set the base card class
                card.className = `alert-card ${alert.triggered ? 'triggered' : ''} ${directionClass}`;
                
                // Set card attributes
                card.setAttribute('data-exchange', alert.exchange || 'NASDAQ');
                card.setAttribute('data-filing-link', alert.filingLink || '');
                card.setAttribute('data-ticker', alert.ticker);
                card.setAttribute('data-position', isShort ? 'short' : 'long');
                
                // Set border color based on position type only
                const isDarkMode = document.body.classList.contains('dark-mode');
                const borderColor = isShort ? 
                    (isDarkMode ? '#00ff00' : '#00cc00') :  // Green for SHORT
                    (isDarkMode ? '#ff3333' : '#ff0000');   // Red for LONG
                
                card.style.borderLeft = `4px solid ${borderColor}`;

                // Set up one-time click handlers
                const setupClickHandlers = () => {
                    const tickerEl = card.querySelector('.ticker-clickable');
                    const dropdownToggle = card.querySelector('.score-details-toggle');
                    
                    if (tickerEl) {
                        // Remove any existing listeners
                        const newTickerEl = tickerEl.cloneNode(true);
                                                tickerEl.parentNode.replaceChild(newTickerEl, tickerEl);
                        
                        // Add single click handler directly to ticker element
                        newTickerEl.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            // Prevent rapid clicking
                            if (newTickerEl.dataset.clicking) return;
                            newTickerEl.dataset.clicking = 'true';
                            this.handleAlertClick(alert, e);
                            setTimeout(() => delete newTickerEl.dataset.clicking, 500);
                        });
                    }
                    
                    if (dropdownToggle) {
                        // Remove any existing listeners
                        const newDropdownToggle = dropdownToggle.cloneNode(true);
                        dropdownToggle.parentNode.replaceChild(newDropdownToggle, dropdownToggle);
                        
                        // Add single click handler directly to dropdown toggle
                        const handleToggleClick = (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            if (e.target === newDropdownToggle) {
                                toggleScoreDetails(newDropdownToggle, e);
                            }
                        };
                        
                        newDropdownToggle.addEventListener('click', handleToggleClick);
                        // Also attach to parent container to ensure event bubbling
                        card.querySelector('.score-details-container').addEventListener('click', handleToggleClick);
                    }
                };
                
                // Calculate display percent (considering reverse split if applicable)
                let percentChange = (alert.priceChange * 100).toFixed(2);
                const isShortSetup = Array.isArray(alert.isShort) ? alert.isShort.length > 0 : (alert.position === 'short' || alert.isShort === true);
                
                // Handle reverse split stocks
                if (alert.reverseSplitRatio && alert.reverseSplitRatio > 1) {
                    // For reverse splits, use adjustedPercent if available from backend
                    if (alert.performance && typeof alert.performance.adjustedPercent === 'number') {
                        percentChange = alert.performance.adjustedPercent.toFixed(2);
                    } else {
                        // Recalculate if not available
                        // Convert post-split price BACK to pre-split basis for accurate comparison
                        const currentPricePreSplit = alert.currentPrice / alert.reverseSplitRatio;
                        
                        if (isShortSetup) {
                            // SHORT: profit when price GOES DOWN from entry
                            // Use pre-split basis: (entry - current) / entry × 100
                            percentChange = (((alert.alertPrice - currentPricePreSplit) / alert.alertPrice) * 100).toFixed(2);
                        } else {
                            // LONG: profit when price GOES UP from entry
                            // Use pre-split basis: (current - entry) / entry × 100
                            percentChange = (((currentPricePreSplit - alert.alertPrice) / alert.alertPrice) * 100).toFixed(2);
                        }
                    }
                } else if (isShortSetup) {
                    // SHORT without reverse split: invert the sign
                    percentChange = (parseFloat(percentChange) * -1).toFixed(2);
                }
                
                const priceDiff = (alert.currentPrice - alert.alertPrice).toFixed(4);
                const volumeRatio = alert.averageVolume > 0 ? (alert.currentVolume / alert.averageVolume).toFixed(1) : 'N/A';
                const exchange = alert.exchange && alert.exchange !== 'N/A' ? alert.exchange : 'NASDAQ';

                // Create the initial HTML content
                card.innerHTML = `
                    <div class="score-details-container" style="position: relative; z-index: 1002;">
                        <button type="button" class="score-details-toggle" style="background: transparent; border: none; cursor: pointer; padding: 2px 4px; margin-right: 4px; font-size: 12px; color: #666; border-radius: 3px; transition: background-color 0.2s, padding 0.2s; position: absolute; top: 8px; right: 6px; z-index: 1003;">⋮</button>
                        <div class="score-breakdown" style="display: none; position: absolute; top: 25px; right: 25px; z-index: 1001; background: rgba(255, 255, 255, 0.95); padding: 3px 5px; border-radius: 3px; width: 274px; pointer-events: auto; backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); border: 1px solid #ddd; font-size: 5px; line-height: 1;">
                            <div class="score-header" style="font-weight: bold; font-size: 9px; margin-bottom: 2px; padding-bottom: 2px; border-bottom: 1px solid rgba(0,0,0,0.06); display: flex; justify-content: space-between; align-items: center;">
                                <span>Price Metrics</span>
                            </div>
                            <div class="score-item" style="display: flex; justify-content: space-between; margin-bottom: 0; font-size: 9px; line-height: 1.25; padding: 2px 3px; border-bottom: 1px solid rgba(0,0,0,0.02);">
                                <span style="font-weight: 500; flex: 1; margin-right: 4px; color: #000;">Alert Price:</span>
                                <span style="font-weight: bold; text-align: right;">$${alert.alertPrice.toFixed(4)}</span>
                            </div>
                            <div class="score-item" style="display: flex; justify-content: space-between; margin-bottom: 0; font-size: 9px; line-height: 1.25; padding: 2px 3px; border-bottom: 1px solid rgba(0,0,0,0.02);">
                                <span style="font-weight: 500; flex: 1; margin-right: 4px; color: #000;">Current Price:</span>
                                <span style="font-weight: bold; text-align: right;">$${alert.currentPrice.toFixed(4)}</span>
                            </div>
                            <div class="score-item" style="display: flex; justify-content: space-between; margin-bottom: 0; font-size: 9px; line-height: 1.25; padding: 2px 3px; border-bottom: 1px solid rgba(0,0,0,0.02);">
                                <span style="font-weight: 500; flex: 1; margin-right: 4px; color: #000;">Peak/Low:</span>
                                <span style="font-weight: bold; text-align: right;">$${Math.max(alert.peakPrice, alert.lowPrice).toFixed(4)}/$${Math.min(alert.peakPrice, alert.lowPrice).toFixed(4)}</span>
                            </div>
                            <div class="section-header" style="font-weight: 600; margin: 4px 0 2px; color: #000; text-transform: uppercase; font-size: 7px; letter-spacing: 0.4px;">Company Information</div>
                            <div class="score-item" style="display: flex; justify-content: space-between; margin-bottom: 0; font-size: 9px; line-height: 1.25; padding: 2px 3px; border-bottom: 1px solid rgba(0,0,0,0.02);">
                                <span style="font-weight: 500; flex: 1; margin-right: 4px; color: #000;">Incorporated:</span>
                                <span style="font-weight: bold; text-align: right;">${alert.incorporated || 'N/A'}</span>
                            </div>
                            <div class="score-item" style="display: flex; justify-content: space-between; margin-bottom: 0; font-size: 9px; line-height: 1.25; padding: 2px 3px; border-bottom: 1px solid rgba(0,0,0,0.02);">
                                <span style="font-weight: 500; flex: 1; margin-right: 4px; color: #000;">Located:</span>
                                <span style="font-weight: bold; text-align: right;">${alert.located || 'N/A'}</span>
                            </div>
                            <div class="section-header" style="font-weight: 600; margin: 4px 0 2px; color: #000; text-transform: uppercase; font-size: 7px; letter-spacing: 0.4px;">Quote Details</div>
                            <div class="score-item" style="display: flex; justify-content: space-between; margin-bottom: 0; font-size: 9px; line-height: 1.25; padding: 2px 3px; border-bottom: 1px solid rgba(0,0,0,0.02);">
                                <span style="font-weight: 500; flex: 1; margin-right: 4px; color: #000;">Float:</span>
                                <span style="font-weight: bold; text-align: right;">${(alert.float / 1000000).toFixed(2)}M</span>
                            </div>
                            <div class="score-item" style="display: flex; justify-content: space-between; margin-bottom: 0; font-size: 9px; line-height: 1.25; padding: 2px 3px; border-bottom: 1px solid rgba(0,0,0,0.02);">
                                <span style="font-weight: 500; flex: 1; margin-right: 4px; color: #000;">S/O:</span>
                                <span style="font-weight: bold; text-align: right;">${alert.soRatio || 'N/A'}</span>
                            </div>
                            <div class="score-item" style="display: flex; justify-content: space-between; margin-bottom: 0; font-size: 9px; line-height: 1.25; padding: 2px 3px;">
                                <span style="font-weight: 500; flex: 1; margin-right: 4px; color: #000;">Score:</span>
                                <span style="font-weight: bold; text-align: right;">${alert.signalScore.toFixed(2)}</span>
                            </div>
                        </div>
                    </div>
                    <div class="ticker ticker-clickable" tabindex="0" style="cursor:pointer;display:inline-block;user-select:none;transition:background 0.15s,border 0.15s; border-radius:4px; padding:2px 6px; margin-bottom:2px; font-size: 8px;">
                    <div class="ticker" style="transition: all 0.15s ease;">
                        <i>$${alert.ticker}</i> 
                        <span style="color: ${alert.isShort ? '#cc0000' : '#00cc00'}; transition: color 0.15s ease;">[${alert.isShort ? 'SHORT' : 'LONG'}]</span>
                    </div>
                    </div><span style="font-size: 0.95em; font-style: italic;">(${(alert.signalScore || 0).toFixed(2)})</span></div>
                    <div>Alert: $${alert.alertPrice.toFixed(4)}</div>
                    <div>Current: $${alert.currentPrice.toFixed(4)} (H/L: $${Math.max(alert.peakPrice, alert.lowPrice).toFixed(4)}/$${Math.min(alert.peakPrice, alert.lowPrice).toFixed(4)})</div>
                    <div class="price-change ${parseFloat(percentChange) > 0 ? 'positive' : (parseFloat(percentChange) === 0 ? 'neutral' : 'negative')}">
                        (${priceDiff > 0 ? '+' : ''}$${Math.abs(priceDiff).toFixed(4)}) ${percentChange > 0 ? '+' : ''}${percentChange}%
                    </div>
                    <div>Volume: ${alert.currentVolume.toLocaleString()} (Avg: ${alert.averageVolume.toLocaleString()}) ${alert.volumeSpike ? '<span class="volume-spike"><i>' + volumeRatio + 'x</i></span>' : ''}</div>
                    <div>Float: ${alert.float.toLocaleString()} (S/O: ${alert.soRatio || 'N/A'})</div>
                    <div class="timestamp" style="color: ${
                        alert.triggered ?
                        (this.isDarkMode() ?
                            ((!alert.isShort && alert.priceChange > 0) || (alert.isShort && alert.priceChange < 0) ? '#ffffff' : '#cccccc') :
                            '#fffffffd') :
                        (this.isDarkMode() ? '#cccccc' : '#333333')                    }">Alert Time: ${alert.alertTime.toLocaleDateString('en-US', { timeZone: 'America/New_York', month: '2-digit', day: '2-digit', year: '2-digit' })} ${alert.alertTime.toLocaleTimeString('en-US', { timeZone: 'America/New_York', hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' })} ET | Updated: ${alert.lastUpdated.toLocaleDateString('en-US', { timeZone: 'America/New_York', month: '2-digit', day: '2-digit', year: '2-digit' })} ${alert.lastUpdated.toLocaleTimeString('en-US', { timeZone: 'America/New_York', hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' })} ET</div>
                    ${alert.triggered || this.milestones.get(alert.ticker) ? `
                    <div class="alerts-container">
                        ${(alert.milestoneEvents && alert.milestoneEvents.length > 0) ? alert.milestoneEvents.map(event => {
                            const color = event.direction === 'up' ? '#00cc00' : '#cc0000';
                        }).join('') : ''}
                    </div>` : ''}
                        <button type="button" class="link-button" onclick="(() => {
                            event.stopPropagation();
                            const ticker = '${alert.ticker}';
                            const exchange = '${alert.exchange || 'NASDAQ'}';
                            console.log('Card TradingView button clicked:', { ticker, exchange });
                            const tvSymbol = getTradingViewSymbol(ticker, exchange);
                            console.log('Generated tvSymbol:', tvSymbol);
                            const url = 'https://www.tradingview.com/chart/?symbol=' + tvSymbol;
                            console.log('Opening URL:', url);
                            customConfirm('Open TradingView Chart for $' + ticker + '?', url);
                        })()">TradingView</button>
                        <button type="button" class="link-button" onclick="(() => {
                            event.stopPropagation();
                            customConfirm('View Financials for $${alert.ticker}?', \`https://stockanalysis.com/stocks/${alert.ticker}/statistics/\`);
                        })()">Financials</button>
                        <button type="button" class="link-button" onclick="(() => {
                            event.stopPropagation();
                            customConfirm('Open Trading 212 to trade $${alert.ticker}?', 'https://www.trading212.com/en/login');
                        })()">Trading 212</button>
                    </div>
                `;
                // Add hover/click animation to ticker/position
                const tickerClickable = card.querySelector('.ticker-clickable');
                if (tickerClickable) {
                    // Just handle the click event, no hover or active styles
                    tickerClickable.addEventListener('click', function(e) {
                        e.stopPropagation();
                        // Only handle the click action, no styles
                    });
                }
                // Set up click handlers after HTML is set
                setupClickHandlers();

                // Restore dropdown state if it was open
                const isOpen = localStorage.getItem(`dropdown_${alert.ticker}`) === 'open' || 
                             window.dropdownStates?.get(alert.ticker)?.isOpen === true;
                if (isOpen) {
                    card.dataset.dropdownOpen = 'true';
                    const dropdown = card.querySelector('.score-breakdown');
                    const button = card.querySelector('.score-details-toggle');
                    if (dropdown && button) {
                        openDropdown(dropdown, button, alert.ticker, card);
                    }
                }

                // Ensure all buttons are properly clickable
                card.querySelectorAll('button').forEach(button => {
                    button.style.pointerEvents = 'auto';
                    button.style.cursor = 'pointer';
                });

                return card;
            }
            
            updateLastUpdate() {
                const lastUpdate = document.getElementById('last-update');
                lastUpdate.textContent = getMarketStatusString();
            }

            isDarkMode() {
                return document.body.classList.contains('dark-mode');
            }

            showNotification(message, type = 'info', link = null) {
                // Stack notifications with comfortable spacing
                const notifications = document.querySelectorAll('.notification');
                const isMobile = window.innerWidth <= 768;
                const spacing = isMobile ? 75 : 80; // Better spacing to prevent overlap
                const offset = notifications.length * spacing;
                const topOffset = isMobile ? 10 : 25; // Higher up on mobile

                // Create new notification
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.style.top = `${topOffset + offset}px`; // Stack from top
                notification.style.right = isMobile ? '8px' : '20px'; // Closer to edge on mobile
                
                // Make notification smaller on mobile
                if (isMobile) {
                    notification.style.padding = '6px 8px';
                    notification.style.fontSize = '10px';
                    notification.style.maxWidth = '160px';
                    notification.style.minWidth = '100px';
                    notification.style.borderRadius = '3px';
                    notification.style.lineHeight = '1.2';
                }

                if (link) {
                    const linkElement = document.createElement('a');
                    linkElement.href = link;
                    linkElement.target = '_blank';
                    linkElement.style.color = 'inherit';
                    linkElement.style.textDecoration = 'none';
                    linkElement.innerHTML = message;
                    notification.appendChild(linkElement);
                } else {
                    notification.innerHTML = message;
                }

                // Add to notification history
                addToNotificationHistory(message, type, link);

                document.body.appendChild(notification);

                // Show notification
                setTimeout(() => notification.classList.add('show'), 10);

                // Auto-hide after 8 seconds
                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => {
                        notification.remove();
                        // Reposition remaining notifications with proper spacing on mobile
                        document.querySelectorAll('.notification').forEach((n, i) => {
                            const isMobile = window.innerWidth <= 768;
                            const spacing = isMobile ? 75 : 80;
                            const topOffset = isMobile ? 10 : 25;
                            n.style.top = `${topOffset + (i * spacing)}px`;
                        });
                    }, 300);
                }, 8000);
            }
        }
        
        // Theme toggle functionality
        function toggleTheme() {
            const body = document.body;
            const header = document.querySelector('.header');
            const themeToggle = document.querySelector('.theme-toggle');
            const sunIcon = themeToggle.querySelector('.theme-icon-light');
            const moonIcon = themeToggle.querySelector('.theme-icon-dark');

            // Use requestAnimationFrame for smoother transitions
            requestAnimationFrame(() => {
                // Store current dropdown states
                const openDropdowns = document.querySelectorAll('.score-breakdown[style*="display: block"]');
                const dropdownStates = Array.from(openDropdowns).map(dropdown => ({
                    dropdown,
                    button: dropdown.previousElementSibling,
                    ticker: dropdown.closest('.alert-card').querySelector('.ticker').textContent.split(' ')[0].replace('$', '')
                }));

                // Toggle theme immediately
                body.classList.toggle('dark-mode');
                header.classList.toggle('dark-mode');

                // Toggle icon visibility
                const isDark = body.classList.contains('dark-mode');
                if (isDark) {
                    sunIcon.style.display = 'none';
                    moonIcon.style.display = 'block';
                } else {
                    sunIcon.style.display = 'block';
                    moonIcon.style.display = 'none';
                }

                // Save theme preference
                localStorage.setItem('theme', isDark ? 'dark' : 'light');

                // Restore dropdowns efficiently
                if (dropdownStates.length) {
                    requestAnimationFrame(() => {
                        dropdownStates.forEach(({ dropdown, button, ticker }) => {
                            dropdown.style.display = 'block';
                            dropdown.style.opacity = '1';
                            dropdown.style.transform = 'translateY(0)';
                            dropdown.style.pointerEvents = 'auto';
                            if (button) button.textContent = '▲';
                            if (ticker === lastActiveTicker) {
                                activeDropdown = dropdown;
                            }
                        });
                    });
                }
            });
        }

        // Load saved theme on page load
        function loadTheme() {
            const savedTheme = localStorage.getItem('theme');
            const themeToggle = document.querySelector('.theme-toggle');
            const sunIcon = themeToggle.querySelector('.theme-icon-light');
            const moonIcon = themeToggle.querySelector('.theme-icon-dark');

            if (savedTheme === 'dark') {
                document.body.classList.add('dark-mode');
                document.querySelector('.header').classList.add('dark-mode');
                sunIcon.style.display = 'none';
                moonIcon.style.display = 'block';
            } else {
                sunIcon.style.display = 'block';
                moonIcon.style.display = 'none';
            }
        }

        // Helper function to determine if an alert is a short setup
        function isShortSetup(alert) {
            // First and foremost, respect the explicit isShort flag from the backend
            if (alert.isShort !== undefined) {
                return alert.isShort;
            }
            
            // Default to long if there's no explicit short signal
            return false;
        }

        // Initialize dashboard when page loads
        document.addEventListener('DOMContentLoaded', () => {
            loadTheme();
            window.dashboard = new AlertDashboard();
            loadRecentAlerts(); // Initialize notification count from alert.json
            dashboard.loadInitialAlerts(); // Load main alerts into dashboard
            updateTimeDisplay();
            setInterval(updateTimeDisplay, 1000); // Update every second

            // Generate unique session ID
            let sessionId = localStorage.getItem('sessionId');
            if (!sessionId) {
                sessionId = 'session-' + Math.random().toString(36).substr(2, 9) + '-' + Date.now();
                localStorage.setItem('sessionId', sessionId);
            }

            // Ping server to update online user count
            const pingServer = async () => {
                try {
                    // Check if viewing from localhost (has local API server)
                    const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                    
                    if (isLocalhost) {
                        // Ping local API server
                        const response = await fetch(`/api/ping?sessionId=${encodeURIComponent(sessionId)}`);
                        if (response.ok) {
                            const data = await response.json();
                            // Update status to online on successful ping
                            const statusEl = document.getElementById('status');
                            if (statusEl) statusEl.className = 'status-online';
                            
                            if (data.onlineUsers) {
                                // Try to find and update the online users span
                                let onlineUsersElement = document.getElementById('online-users');
                                if (!onlineUsersElement) {
                                    // If the span doesn't exist, recreate it in the status div
                                    const statusEl = document.getElementById('status');
                                    if (statusEl) {
                                        statusEl.innerHTML = `Online: <span id="online-users">${data.onlineUsers}</span>`;
                                    }
                                } else {
                                    onlineUsersElement.textContent = data.onlineUsers;
                                }
                            }
                        } else {
                            // Set status to offline on failed response
                            const statusEl = document.getElementById('status');
                            if (statusEl) statusEl.className = 'status-offline';
                        }
                    } else {
                        // Viewing from GitHub Pages / custom domain - if we got alerts loaded, we're online
                        const statusEl = document.getElementById('status');
                        if (statusEl) {
                            // Check if alert data is loading (indicates bot is pushing updates)
                            try {
                                const response = await fetch('https://raw.githubusercontent.com/heyitshurberto/sysd/main/logs/alert.json');
                                if (response.ok) {
                                    statusEl.className = 'status-online';
                                } else {
                                    statusEl.className = 'status-offline';
                                }
                            } catch (err) {
                                statusEl.className = 'status-offline';
                            }
                        }
                    }
                } catch (err) {
                    // Silently fail - don't spam console with network errors
                }
            };

            // Initial ping
            pingServer();
            // Ping every 30 seconds
            setInterval(pingServer, 30000);

            // Close dropdowns when clicking outside
            document.addEventListener('click', function(event) {
                const clickedDropdown = event.target.closest('.score-breakdown');
                const clickedToggle = event.target.closest('.score-details-toggle');
                const clickedButton = event.target.closest('button');
                const clickedCard = event.target.closest('.alert-card');
                
                // Don't interfere with any card interactions
                if (clickedDropdown || clickedToggle || clickedButton || clickedCard) {
                    return;
                }
                
                // Only close dropdowns when clicking completely outside of cards
                document.querySelectorAll('.score-breakdown').forEach(dropdown => {
                    const card = dropdown.closest('.alert-card');
                    const ticker = card?.getAttribute('data-ticker');
                    
                    if (dropdown.style.display === 'block') {
                        closeDropdown(
                            dropdown,
                            card?.querySelector('.score-details-toggle'),
                            ticker,
                            card
                        );
                    }
                });
            });
        });

        let loggedMessages = new Set();
        // Smart logging function to prevent duplicates
        function smartLog(type, message, force = false) {
            const key = `${type}:${message}`;
            if (!loggedMessages.has(key) || force) {
                loggedMessages.add(key);
                if (type === 'error') {
                    console.error(message);
                } else {
                    console.log(message);
                }
                // Clear old messages after 1000 entries
                if (loggedMessages.size > 1000) {
                    loggedMessages.clear();
                }
            }
        }

        // Handle dropdown visibility
        let activeDropdown = null;
        let lastActiveTicker = null; // Track which ticker's dropdown was last open

        // Score details toggle function
        function toggleScoreDetails(button, event) {
            if (!button) return;
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            
            // Get all the elements we need
            const card = button.closest('.alert-card');
            if (!card) return;
            
            const dropdown = card.querySelector('.score-breakdown');
            if (!dropdown) return;
            
            const tickerElement = card.querySelector('.ticker');
            if (!tickerElement) return;
            
            const tickerText = tickerElement.textContent.trim();
            const currentTicker = tickerText.split(' ')[0].replace('$', '');
            
            // Close any other open dropdowns first
            document.querySelectorAll('.score-breakdown').forEach(d => {
                if (d !== dropdown && d.style.display === 'block') {
                    const otherCard = d.closest('.alert-card');
                    if (otherCard) {
                        const otherButton = otherCard.querySelector('.score-details-toggle');
                        const otherTickerEl = otherCard.querySelector('.ticker');
                        if (otherButton && otherTickerEl) {
                            const otherTicker = otherTickerEl.textContent.trim().split(' ')[0].replace('$', '');
                            closeDropdown(d, otherButton, otherTicker, otherCard);
                        }
                    }
                }
            });
            
            // Initialize window-level state storage if not exists
            if (!window.dropdownStates) {
                window.dropdownStates = new Map();
            }
            
            // Get current state
            const isCurrentlyOpen = dropdown.style.display === 'block';
            
            // Toggle based on current visual state
            if (isCurrentlyOpen) {
                closeDropdown(dropdown, button, currentTicker, card);
                window.dropdownStates.delete(currentTicker);
                localStorage.removeItem(`dropdown_${currentTicker}`);
                card.dataset.dropdownOpen = 'false';
            } else {
                openDropdown(dropdown, button, currentTicker, card);
                window.dropdownStates.set(currentTicker, {
                    isOpen: true,
                    timestamp: Date.now()
                });
                localStorage.setItem(`dropdown_${currentTicker}`, 'open');
                card.dataset.dropdownOpen = 'true';
            }

            // Update active references
            activeDropdown = isCurrentlyOpen ? null : dropdown;
            lastActiveTicker = isCurrentlyOpen ? null : currentTicker;

            // Ensure the button still works after animation
            button.style.pointerEvents = 'auto';
            
            // Stop event propagation
            if (event) {
                event.stopImmediatePropagation();
            }
            return false;
        }

        function openDropdown(dropdown, button, ticker, card) {
            // Ensure the button remains clickable
            button.style.pointerEvents = 'auto';
            
            // Calculate position
            const buttonRect = button.getBoundingClientRect();
            const cardRect = card.getBoundingClientRect();
            
            // Position dropdown relative to viewport
            dropdown.style.position = 'fixed';
            dropdown.style.top = (buttonRect.bottom + 40) + 'px';
            dropdown.style.left = (cardRect.right + 105) + 'px'; // 180px width + 10px offset
            
            // Set display block first to allow animation
            dropdown.style.display = 'block';
            dropdown.style.opacity = '0';
            dropdown.style.transform = 'translateY(-10px) translateZ(0)';
            
            // Force a reflow to ensure animation works
            dropdown.offsetHeight;
            
            // Apply animations with RAF for smoothness
            requestAnimationFrame(() => {
                dropdown.style.opacity = '1';
                dropdown.style.transform = 'translateY(0) translateZ(0)';
                dropdown.style.pointerEvents = 'auto';
            });
            
            button.textContent = '▲';
            localStorage.setItem(`dropdown_${ticker}`, 'open');
            card.dataset.dropdownOpen = 'true';
            
            // Store state in window-level persistence
            window.dropdownStates = window.dropdownStates || new Map();
            window.dropdownStates.set(ticker, {
                isOpen: true,
                timestamp: Date.now()
            });
            
            // Create mutation observer to maintain state
            if (!dropdown._observer) {
                dropdown._observer = new MutationObserver(() => {
                    if (window.dropdownStates.get(ticker)?.isOpen) {
                        requestAnimationFrame(() => {
                            dropdown.style.display = 'block';
                            dropdown.style.opacity = '1';
                            dropdown.style.transform = 'translateY(0)';
                            dropdown.style.pointerEvents = 'auto';
                        });
                    }
                });
                
                dropdown._observer.observe(dropdown, {
                    attributes: true,
                    attributeFilter: ['style', 'class']
                });
            }
        }

        function closeDropdown(dropdown, button, ticker, card) {
            // Animate out
            dropdown.style.opacity = '0';
            dropdown.style.transform = 'translateY(-10px)';
            dropdown.style.pointerEvents = 'none';
            
            // Delay hiding to allow animation
            setTimeout(() => {
                if (!window.dropdownStates.get(ticker)?.isOpen) {
                    dropdown.style.display = 'none';
                }
            }, 150);
            
            // Arrow removed
            localStorage.removeItem(`dropdown_${ticker}`);
            card.dataset.dropdownOpen = 'false';
            
            // Clear window-level state
            if (window.dropdownStates) {
                window.dropdownStates.delete(ticker);
            }
            
            // Disconnect observer if exists
            if (dropdown._observer) {
                dropdown._observer.disconnect();
                delete dropdown._observer;
            }
        }

                // Debounce function to prevent rapid-fire events
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // Handle document clicks to close dropdowns when clicking outside
        document.addEventListener('click', function(event) {
            const clickedInside = event.target.closest('.score-breakdown, .score-details-toggle');
            if (clickedInside) {
                event.stopPropagation();
                return;
            }

            // Close all dropdowns when clicking outside
            document.querySelectorAll('.score-breakdown').forEach(dropdown => {
                if (dropdown.style.display === 'block') {
                    const button = dropdown.closest('.alert-card').querySelector('.score-details-toggle');
                    const ticker = dropdown.closest('.alert-card').getAttribute('data-ticker');
                    closeDropdown(dropdown, button, ticker, dropdown.closest('.alert-card'));
                }
            });
        });

        function updateTimeDisplay() {
            const now = new Date();

            // UK date and time (London)
            const ukDate = now.toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit', year: '2-digit' });
            const ukTime = now.toLocaleTimeString('en-GB', {
                timeZone: 'Europe/London',
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });

            // US market time (New York)
            const usTime = now.toLocaleTimeString('en-US', {
                timeZone: 'America/New_York',
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });

            // India time (Goa/Kolkata)
            const indiaTime = now.toLocaleTimeString('en-IN', {
                timeZone: 'Asia/Kolkata',
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });

            const timeDisplay = document.getElementById('time-display');
            timeDisplay.innerHTML = `${ukDate} | UK: ${ukTime} | US: ${usTime} | IN: ${indiaTime}`;
        }
        
        // Helper function to format market cap string
        function formatAlertAge(alertTime) {
            const now = new Date();
            const diff = now - alertTime;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(minutes / 60);
            
            if (minutes < 60) {
                return `${minutes}m ago`;
            } else if (hours < 24) {
                return `${hours}h ${minutes % 60}m ago`;
            } else {
                const days = Math.floor(hours / 24);
                return `${days}d ${hours % 24}h ago`;
            }
        }

        // WebSocket for real-time updates from your Node.js app
        function connectWebSocket() {
            const ws = new WebSocket('ws://localhost:8080');

            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);

                if (data.type === 'new_alert') {
                    window.dashboard.addAlert(data.alert);
                }
            };

            ws.onclose = function() {
                // Reconnect after 5 seconds
                setTimeout(connectWebSocket, 5000);
            };

            ws.onerror = function() {
                // Error handling without status update
            };
        }

        // Pitch-based alert sounds
        const ALERT_SOUNDS = {
          '12%': 800,   // Mid pitch - "heads up"
          '25%': 1200,  // Higher pitch - "working"
          '50%': 1600,  // High pitch - "exceptional"
          '100%+': 400  // Low pitch - "life-changing"
        };

        function playTieredAlert(percentChange) {
          const absChange = Math.abs(percentChange);
          let frequency = 0;

          if (absChange >= 1.00) frequency = 1600; // Very High
          else if (absChange >= 0.65) frequency = 1200; // High
          else if (absChange >= 0.35) frequency = 800; // Medium base
          else if (absChange >= 0.12) frequency = 400; // Deep bass

          if (frequency > 0) {
            playTone(frequency, 750); // 750ms duration
          }
        }

        function playTone(frequency, duration) {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();

          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);

          oscillator.frequency.value = frequency;
          oscillator.type = 'sine'; // Clean tone

          gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + (duration / 1000));

          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + (duration / 1000));
        }

        // Notification history management
        let notifications = [];
        let notificationCount = 0;

        
        function updateNotificationCount() {
            const count = document.getElementById('notification-count');
            count.textContent = notifications.length;
        }

        function formatNotificationTime(date) {
            const now = new Date();
            const diff = now - date;
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 0) return days + 'd';
            if (hours > 0) return hours + 'h';
            if (minutes > 0) return minutes + 'm';
            return seconds + 's';
        }

        function updateNotificationPanel() {
            const list = document.getElementById('notification-list');
            list.innerHTML = notifications.map(n => `
                <div class="notification-item ${n.type}" data-id="${n.id}">
                    <div class="notification-content">${n.message}</div>
                    <div class="notification-time short" data-timestamp="${n.timestamp}">${formatNotificationTime(n.timestamp)}</div>
                </div>
            `).join('');
            
            // Start auto-updating timestamps
            if (!window.timeUpdateInterval) {
                window.timeUpdateInterval = setInterval(() => {
                    document.querySelectorAll('.notification-time').forEach(el => {
                        const timestamp = new Date(el.getAttribute('data-timestamp'));
                        el.textContent = formatNotificationTime(timestamp);
                    });
                }, 1000);
            }
            // Add custom confirm to each notification link
            Array.from(list.querySelectorAll('.notification-item')).forEach((item, idx) => {
                const n = notifications[idx];
                if (n.link) {
                    item.style.cursor = 'pointer';
                    item.onclick = async (e) => {
                        e.preventDefault();
                        let confirmMsg = '';
                        // Extract ticker more reliably
                        let ticker = '';
                        const messageWords = n.message.split(' ');
                        // First try to find a word starting with $
                        for (const word of messageWords) {
                            if (word.startsWith('$')) {
                                ticker = word.substring(1); // Remove the $ symbol
                                break;
                            }
                        }
                        // If no ticker found with $, find first word that looks like a ticker (all caps)
                        if (!ticker) {
                            for (const word of messageWords) {
                                const cleanWord = word.replace(/[^A-Z]/g, ''); // Remove any non-capital letters
                                if (cleanWord.length >= 2 && cleanWord === word.toUpperCase()) {
                                    ticker = cleanWord;
                                    break;
                                }
                            }
                        }
                        
                        if (n.link.includes('tradingview.com')) {
                            if (n.message.includes('momentum')) {
                                confirmMsg = n.type === 'success' 
                                    ? `View ${ticker} chart for +${n.message.match(/\d+/)}% momentum?`
                                    : `View ${ticker} chart for -${n.message.match(/\d+/)}% momentum?`;
                            } else if (n.message.includes('LONG')) {
                                confirmMsg = `View ${ticker} chart for new LONG position?`;
                            } else if (n.message.includes('SHORT')) {
                                confirmMsg = `View ${ticker} chart for new SHORT position?`;
                            } else {
                                confirmMsg = `Open TradingView chart for ${ticker}?`;
                            }
                        } else if (n.link.includes('sec.gov') || n.link.includes('filingLink')) {
                            if (n.message.includes('LONG')) {
                                confirmMsg = `View Financials for new ${ticker} alert?`;
                                if (await customConfirm(confirmMsg)) {
                                    window.open(`https://stockanalysis.com/stocks/${ticker}/statistics/`, '_blank');
                                    return;
                                }
                            } else if (n.message.includes('SHORT')) {
                                confirmMsg = `View Financials for new ${ticker} alert?`;
                                if (await customConfirm(confirmMsg)) {
                                    window.open(`https://stockanalysis.com/stocks/${ticker}/statistics/`, '_blank');
                                    return;
                                }
                            } else {
                                confirmMsg = `View Financials for $${ticker}?`;
                            }
                        } else {
                            confirmMsg = `View details for $${ticker}?`;
                        }
                        
                        if (await customConfirm(confirmMsg)) {
                            setTimeout(() => window.open(n.link, '_blank'), 100);
                        }
                    };
                }
            });
        }





        // Update the showNotification method to add to history
        AlertDashboard.prototype.showNotification = function(message, type = 'info', link = null) {
            // Make sure type is correctly set based on message content
            if (message.includes(' up ')) {
                type = 'success';
            } else if (message.includes(' down ')) {
                type = 'error';
            } else if (message.includes('LONG')) {
                type = 'success';
            } else if (message.includes('SHORT')) {
                type = 'error';
            }
            
            // Add to history first
            addToNotificationHistory(message, type, link);
            
            // Rest of the existing notification code...
            const notifications = document.querySelectorAll('.notification');
            const isMobile = window.innerWidth <= 768;
            const offset = notifications.length * (isMobile ? 75 : 80);
            const topOffset = isMobile ? 10 : 25;

            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.style.top = `${topOffset + offset}px`; // Consistent spacing
            notification.style.right = isMobile ? '10px' : '20px';
            notification.style.opacity = document.body.classList.contains('dark-mode') ? '0.95' : '0.85'; // More visible in dark mode
            
            // Make smaller on mobile
            if (isMobile) {
                notification.style.padding = '8px 10px';
                notification.style.fontSize = '10px';
                notification.style.maxWidth = '180px';
                notification.style.minWidth = '100px';
                notification.style.borderRadius = '4px';
            }

            // Create a wrapper div for better styling
            const contentWrapper = document.createElement('div');
            contentWrapper.style.display = 'flex';
            contentWrapper.style.flexDirection = 'column';
            contentWrapper.style.gap = isMobile ? '2px' : '4px';

            if (link) {
                const linkElement = document.createElement('div');
                linkElement.style.cursor = 'pointer';
                linkElement.style.color = 'inherit';
                linkElement.style.textDecoration = 'none';
                linkElement.innerHTML = message;
                linkElement.onclick = async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const ticker = message.split(' ')[0];
                    let confirmMsg = '';
                    
                    if (link.includes('tradingview.com')) {
                        if (message.includes('momentum')) {
                            confirmMsg = `View $${ticker} momentum chart?`;
                        } else if (message.includes('LONG')) {
                            confirmMsg = `View $${ticker} chart for LONG position?`;
                        } else if (message.includes('SHORT')) {
                            confirmMsg = `View $${ticker} chart for SHORT position?`;
                        } else {
                            confirmMsg = `View $${ticker} chart?`;
                        }
                    } else if (link.includes('sec.gov') || link.includes('filingLink')) {
                        confirmMsg = `View Financials for ${ticker}?`;
                        link = `https://stockanalysis.com/stocks/${ticker}/statistics/`;
                    } else {
                        confirmMsg = `View details for ${ticker}?`;
                    }
                    
                    if (await customConfirm(confirmMsg)) {
                        window.open(link, '_blank');
                    }
                };
                contentWrapper.appendChild(linkElement);
            } else {
                contentWrapper.innerHTML = message;
            }

            notification.appendChild(contentWrapper);
            document.body.appendChild(notification);
            setTimeout(() => notification.classList.add('show'), 10);
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    notification.remove();
                    const isMobile = window.innerWidth <= 768;
                    document.querySelectorAll('.notification').forEach((n, i) => {
                        const spacing = isMobile ? 75 : 80;
                        const topOffset = isMobile ? 10 : 25;
                        n.style.top = `${topOffset + (i * spacing)}px`;
                    });
                }, 300);
            }, 8000);
        };

        // Start WebSocket connection
        connectWebSocket();
        // Helper to robustly display mapped city/country for SEC code or country name
        function getLocationDisplay(val) {
            if (!val) return 'N/A';
            if (val.toLowerCase() === 'other') return 'Not Found';
            // First try exact code match
            if (SEC_CODE_TO_COUNTRY[val]) {
                return SEC_CODE_TO_COUNTRY[val];
            }
            // Try uppercase code match
            if (SEC_CODE_TO_COUNTRY[val.toUpperCase()]) {
                return SEC_CODE_TO_COUNTRY[val.toUpperCase()];
            }
            // Try to find any matching entry
            const lower = val.toLowerCase();
            for (const [code, mapped] of Object.entries(SEC_CODE_TO_COUNTRY)) {
                if (mapped.toLowerCase() === lower || code.toLowerCase() === lower) {
                    return mapped;
                }
            }
            // Try to find any partial match in the city/country string
            for (const mapped of Object.values(SEC_CODE_TO_COUNTRY)) {
                if (mapped.toLowerCase().includes(lower)) {
                    return mapped;
                }
            }
            return val;
        }

        function getMarketStatusString() {
            const now = new Date();
            const nyNow = new Date(now.toLocaleString('en-US', { timeZone: 'America/New_York' }));
            const hour = nyNow.getHours();
            const minutes = nyNow.getMinutes();
            const dayOfWeek = nyNow.getDay();

            // Check if it's a weekend
            if (dayOfWeek === 0 || dayOfWeek === 6) {
                return 'Closed (Weekend)';
            }

            // Create today's market open and close times
            const marketOpen = new Date(nyNow);
            marketOpen.setHours(9, 30, 0, 0);
            const marketClose = new Date(nyNow);
            marketClose.setHours(16, 0, 0, 0);

            // Format time function
            function formatTimeLeft(ms) {
                const hours = Math.floor(ms / (1000 * 60 * 60));
                const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
                return `${hours}h ${minutes}m`;
            }

            const statusDiv = document.getElementById('market-status');

            if (nyNow < marketOpen) {
                // Market not open yet
                statusDiv.textContent = 'Market Opens:';
                return formatTimeLeft(marketOpen - nyNow);
            } else if (nyNow >= marketOpen && nyNow < marketClose) {
                // Market is open
                statusDiv.textContent = 'Market Closes:';
                return formatTimeLeft(marketClose - nyNow);
            } else {
                // Market closed for the day
                // Calculate next open (tomorrow)
                const tomorrowOpen = new Date(marketOpen);
                tomorrowOpen.setDate(marketOpen.getDate() + 1);
                statusDiv.textContent = 'Market Opens:';
                return formatTimeLeft(tomorrowOpen - nyNow);
            }
        }

        function getMarketTimeWindow(date) {
            // US market hours: 9:30 AM to 4:00 PM ET
            const d = new Date(date);
            const ny = new Date(d.toLocaleString('en-US', { timeZone: 'America/New_York' }));
            const hour = ny.getHours();
            const minute = ny.getMinutes();
            const totalMinutes = hour * 60 + minute;
            if (totalMinutes < 570) return 'Pre-Market'; // before 9:30
            if (totalMinutes >= 570 && totalMinutes < 960) return 'Market Hours'; // 9:30-16:00
            return 'After Hours'; // after 16:00
        }

    </script>
</body>
</html>
